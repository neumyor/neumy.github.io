<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>对结对编程的个人理解</title>
    <link href="/2022/03/07/PairProgramming/"/>
    <url>/2022/03/07/PairProgramming/</url>
    
    <content type="html"><![CDATA[<h1 id="结对编程-Pair-Programming"><a href="#结对编程-Pair-Programming" class="headerlink" title="结对编程 Pair Programming"></a>结对编程 Pair Programming</h1><h2 id="How-to-define-it？"><a href="#How-to-define-it？" class="headerlink" title="How to define it？"></a>How to define it？</h2><blockquote><p>Pair programming consists of two programmers sharing a single workstation (one screen, keyboard and mouse among the pair). The programmer at the keyboard is usually called the “driver”, the other, also actively involved in the programming task but focusing more on overall direction is the “navigator”; it is expected that the programmers swap roles every few minutes or so.</p></blockquote><p>我们常说的<strong>Agile</strong> Software Development，可以理解为一系列方法以及实践的总称。这些方法各不相同，但是都围绕着敏捷的价值观。其中，我们又可以specify出<strong>XP</strong>，也就是极限编程框架。他是敏捷开发方法中的一个典型代表。而就在XP的核心价值观下，我们又可以进一步定义出Pair Programming。</p><p>从形式上来说，Pair Programming可以简单地被描述为在找一个伙伴，一人编码实践一人审查并提出建议，两人保持有规律的轮换以避免疲劳。这一过程是在同一台机器、同一个工位完成的。</p><h2 id="Why-do-we-need-it"><a href="#Why-do-we-need-it" class="headerlink" title="Why do we need it?"></a>Why do we need it?</h2><p>XP中的核心价值观可以被描述为：<strong>沟通、简单、反馈、勇气、尊重</strong>，而我们可以从这些角度去思考Pair Programming的意义：</p><ul><li>沟通：结对编程意味着高强度的交流互动，是<strong>持续的、无间断的、口头的交流</strong>。XP的概念中，这种交流是协作的基础，脱离这种交流将带来极大的风险。从实践上看，这种交流方式在效率上远高于文档和报表。这种沟通同时也能更好地<strong>促进团队内的知识传播</strong>，使得每个组件都能够为更多的开发人员所了解。</li><li>反馈：XP强调团队和用户之间的反馈，也强调团队内部的反馈。对于后者，Pair Programming显然能够在两位Programmer之间提供<strong>及时的持续的明确的反馈</strong>。XP的概念中，这种反馈能够及时暴露软件状态中存在的问题，显著<strong>提高代码质量</strong>。</li><li>勇气：XP中勇气指的是Programmer需要拥有面对无法预知的快速需求变化时的勇气。Pair Programming在枯燥的开发过程中带来了一位对等的伙伴，这使得Programmer从心理上更加勇于应对挑战。</li></ul><p>（我不大好去定义Pair Programming在简单和尊重方面的意义，因为感觉作用比较有限）</p><p>除此之外，Pair Programming还带了一些其他显著优势：</p><ul><li>将协调的工作直接减半。协调管理$N$个成员，总是比协调$N/2$个成员简单。</li><li>降低被打断带来的影响。当编程过程被外界因素打断时（外卖到了/工作群里有新消息），一个人可以去处理这些事情，而另一个人可以继续专心编程。</li></ul><h2 id="One-more-thing……"><a href="#One-more-thing……" class="headerlink" title="One more thing……"></a>One more thing……</h2><p>Pair Programming 也有适用场景的限制，如果出现以下情境需要谨慎使用：</p><ul><li>处于探索阶段的项目，需要大量脑力思考：写算法、打ACM等</li><li>后期维护工作且技术含量不高：此时保持复审制度即可，没必要浪费一个人力守在旁边</li><li>两位Programmer素来关系不和</li><li>两位Programmer有明显等级差距：比如“老带新”，新人很可能非常被动，使得沟通过程很地狱</li></ul><h2 id="One-last-thing……"><a href="#One-last-thing……" class="headerlink" title="One last thing……"></a>One last thing……</h2><p>我有看到一些关于Pair Programming实践中，如何使用合适的语言和方式来推进两人的合作。包括如何说服对方、如何读懂潜台词、如何观测对方的肢体语言……我觉得吧，这实在有点太detail了【笑】，有兴趣的话可以看看<a href="https://www.cnblogs.com/xinz/archive/2011/08/22/2148776.html">两人如何合作做汉堡包</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>软工第一次阅读作业</title>
    <link href="/2022/03/06/Homework1forSoftwareEngineering/"/>
    <url>/2022/03/06/Homework1forSoftwareEngineering/</url>
    
    <content type="html"><![CDATA[<h1 id="软工第一次阅读作业"><a href="#软工第一次阅读作业" class="headerlink" title="软工第一次阅读作业"></a>软工第一次阅读作业</h1><p>19373682 牛易明</p><p>[TOC]</p><h2 id="关于《构建之法-现代软件工程》读后的若干疑惑"><a href="#关于《构建之法-现代软件工程》读后的若干疑惑" class="headerlink" title="关于《构建之法-现代软件工程》读后的若干疑惑"></a>关于《构建之法-现代软件工程》读后的若干疑惑</h2><ol><li><p>软件工程概论一节中：</p><blockquote><p>在成熟的航空工业中，一个飞机发动机从构思到最后运行，不知道要经历过多少人, 多少工序，多少流程，多少相关知识的验证。我们无法想象，如果最后某个商用型号的发动机在飞行时发现问题，最初的设计师会自己爬到引擎中敲敲打打，然后钻出来说，“继续飞吧，我搞定了”。然而, 在软件行业中, 很多软件工程师往往以做这样的事而自豪。</p></blockquote><p>这一段中，作者将航空工业与软件工程进行了类比，并指出两者之间在维护层次上的差异性。据我理解，作者的意图是指出维护软件对软件工程师来说是一件值得自豪的事情，因为这意味着软件可以不断迭代完善。但是显然，<strong>商用民航发动机应当对标的性命攸关的软件，而不是普通的商用软件</strong>。</p><p>《Code Complete》一书中曾提到商用系统是高度迭代的，这意味着允许错误是必要的。然而性命攸关系统，比如医疗系统和航天系统，是需要进行序列式开发的（正如航空发动机一样）。我很难不去怀疑，1996年<a href="https://blog.csdn.net/zhzht19861011/article/details/52424077">Ariane 5火箭系统</a>的最初设计者，在火箭爆炸后修复软件BUG时，会感到的是自豪还是自责。</p></li><li><p>工程师的能力评估和发展一节中：</p><blockquote><p>软件设计工程师们在做代码复审的时候，是看“重复字”的多少, 还是程序的艺术性?</p></blockquote><p>这一段中，作者将编程与艺术进行对比，来引发我们对创造性和规范性之间的思考。据我理解，“避免重复字”可以视作诗歌创作的一条规范，而违背这一规范并不影响诗歌的艺术性。</p><p>我们不妨去思考，规范是如何产生的？这里我也像前一章节一样引用民航业作为例子。民航爱好者都知道，“<strong>航空法规是用血与生命换来的</strong>”，每一条条例的背后都可能是一场无比惨烈的空难。911后，<a href="https://www.guancha.cn/ZhangZhongZuo/2021_09_12_606780_s.shtml">美国的很多机场才开始重视机场安检</a>。</p><p>回到文中的例子。苏东坡的诗歌违反了重字规范，但是并没有影响他的艺术性。但是当我们放眼历史时，总能看到那些因为违反重字规范而显得无聊枯燥的诗歌。如果我们看到一趟没有进行安检的航班顺利完成它的旅程，就片面地认为遵守规范并没有意义，那么总有一天会面临911那样的灭顶之灾。</p><p>对于软件来说，我认为也是一样的。<strong>遵守规范或许不会总是有用，但是抛弃规范而追求艺术性，总是要承担更高的不可预料的风险</strong>。我的困惑是，在实际软件工程中，我们如何去评估追求艺术性带来的风险呢？以及如何依据评估结果来制定规范？</p></li><li><p>技能的反面一节中：</p><blockquote><p>那怎么提高技能呢? 答案很简单, 通过不断的练习, 把那些低层次的问题都解决了, 变成不用经过大脑的自动操作, 然后才有时间和脑力来解决较高层次的问题。</p></blockquote><p>这一段中，作者指出技能的反面是过于着重于具体地解决低层次问题。</p><p>我的疑惑在于，我们如何区分高层次与低层次。文中作者指出，“需要花费脑力解决”是更高层次问题的一个关键特征，而可以通过自动化的熟练度来解决的问题通常是是一个低层次的问题。</p><p>但是显然，当我们经常思考一类问题时，下一次遇到类似问题我们其实也可以仿佛直觉般不经思考得出答案，那么这种行为是否<strong>模糊了高层次与低层次之间的界限</strong>？以数学为例，掌握和使用基本积分公式可以视作低层次的行为，而使用公式解决复杂积分问题可以视作高层次问题，但是熟练的数学竞赛同学完全可以不经思考地对复杂积分问题进行分解，那么此时如何定义层次呢？</p><p>我的疑惑是，是否针对不同的人而有不同的高低层次的判断标准呢？根据人的认知程度不同，“技能”这一概念是否也有不同？</p></li><li><p>软件的质量保证和测试中，提到：</p><blockquote><p>即使你的软件产品功能100% 符合spec 的要求，但是用户也可能非常恨你的软件。这时，测试人员就没有尽到责任，因为测试人员要从用户的角度出发，测试软件。</p></blockquote><p>这一段中，作者反对了测试人员机械地对着规格说明书进行测试这一现象。引起我疑惑的是“测试人员需要从用户的角度出发测试软件”这一点。</p><p>根据我的了解，测试人员在很多软件团队中处于一个尴尬的位置。大部分公司甚至没有专门的测试人员，而让开发人员兼职。因此，很多时候即使是专业的测试人员，其素质水平和能力也不尽如人意。同时，我还参考了各大招聘网站对测试工程师这一岗位的要求以及面试情况，<strong>通常都集中于测试方法的了解和使用以及工作经验上</strong>，而鲜有“面向用户进行测试”的要求。</p><p>因此，“面向用户进行测试”的能力对于团队中的测试人员来说是否是必须的呢？<strong>一个懂得用户体验的测试人员对于团队来说是否冗余呢</strong>？（尤其当团队已经存在对用户需求进行分析的专职人员时）。</p></li><li><p>用户调研一节中，提到了一个有趣的问题：</p><blockquote><p>当你的公司要你用数据来证明 41 种蓝色到底哪一种更好, 或者为一个边栏宽度是3, 4, 或5 而争执不休, 纷纷表示要拿数据来证明的时候, 你怎么办?</p></blockquote><p>这一段中，作者引用了Google视觉设计主管Douglas Bowman的一段经历来发出这个问题，从而说明过度强调用户调研带来的问题。引起我的困惑的是，为什么Google这么一家理应如此精通此道的公司，会在这么一个问题上犯如此明显的错误？</p><p>当这段问题被单独提出来时，显然任何一个开发人员都会觉得好笑。那么<strong>当时参与这场争执的工作人员难道不会意识到如此引人发笑的问题的存在吗</strong>？问题究竟出在哪里？</p><p>我通过调研求证了上述这一例子，并找到了出处——Douglas Bowman离开谷歌时的文章<a href="https://stopdesign.com/archive/2009/03/20/goodbye-google.html">Goodbye, Google </a>。文中他提到，在他开始掌管视觉设计团队时，<strong>Google的视觉设计人员都是一批精通工程却从未真正领导过视觉设计的科班人才</strong>。Douglas指出”<em>When a company is filled with engineers, it turns to engineering to solve problems</em>“，这使得任何问题最终都转变为逻辑问题，并最终导致了这种令人哭笑不得的问题。</p><p>因此，我觉得这里引用Douglas的例子可能更能够说明的是，这种闹剧来自于团队的思考方式，而与过度依赖用户调研关系不大，因为这种团队会过度依赖一切可以量化乃至逻辑化的东西，不仅仅是用户调研。</p></li><li><p>软件工程师的誓言一节中，提到：</p><blockquote><p>5.11 不要求软件工程师去做任何与道德规范相违背的事；</p><p>8.07. 不因为偏见而对任何人不公。</p></blockquote><p>这一段，主要引发我思考的是最近的乌克兰冲突中，GitLab将图标换为蓝黄二色以表明对乌克兰的支持立场</p><blockquote><p>当然，GitLab的开发者就是乌克兰人……</p></blockquote><p>越来越多的事实表明，即使科学是无国界的，技术仍然是有国界的。我们暂且不讨论俄乌双方的道德立场，仅就这一个问题进行思考：“软件工程人员是否应该在其软件中掺杂偏见”。软件工程人员也是人，而人是允许持有偏见的（即使这并不提倡），但是是否应将这种偏见引入自己的软件中呢？</p><p>或许，处于商业和政治的考量，软件公司应该可以决定是否对特定国家提供软件产品，这是无法避免的利益冲突与取舍。但是软件的构建过程是否应该成为国际斗争的阵地呢？当我们将一串不友好的注释写在源代码里，在那一刻我们是否就失去了成为合格软件工程从业人员的资格呢？</p></li></ol><hr><h2 id="对基于Git的源代码版本管理软件的调研"><a href="#对基于Git的源代码版本管理软件的调研" class="headerlink" title="对基于Git的源代码版本管理软件的调研"></a>对基于Git的源代码版本管理软件的调研</h2><p>Git是第三代的分布式的版本管理系统，这意味着无需集中式的大型中心存储器，因此开发人员可以在不联网的情况下仍然在本地仓库中进行开发，然后在网络通畅时提交到远程仓库即可。</p><h3 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h3><p>GitHub是一个基于Git实现的在线代码仓库，是<strong>全球最大的代码托管平台</strong>，托管着许许多多优秀知名的项目，包括Spring、Vue等。目前处于微软旗下。</p><p>GitHub同时提供公有仓库和私有仓库，但是私有仓库需要进行一定的收费。鉴于开源项目的公开性以及GitHub本身巨大的用户数量，对于开源项目来说GitHub更具有吸引力。</p><h3 id="GitLab"><a href="#GitLab" class="headerlink" title="GitLab"></a>GitLab</h3><p>GitLab是一个用于仓库管理系统的开源软件项目，采用了Git作为代码管理工具。任何人都可以使用它搭建自己的在线代码仓库。</p><p>由于<strong>GitLab本质上是开源软件</strong>而不是第三方平台，因此对于企业开发团队来说，GitLab能够提供远比GitHub多得多的控制性。</p><h3 id="Gitee"><a href="#Gitee" class="headerlink" title="Gitee"></a>Gitee</h3><p>Gitee是国内对标GitHub的在线代码托管平台，在此基础上额外添加了许多功能，并在企业级的私有仓库开发上允许5人的小团队免费使用。</p><p>Gitee对国内通讯软件以及工作流软件的支持更好，提供了<strong>一些更加企业向和产业向的管理功能</strong>。但是用户群体显然较小，而且促销广告多，社区版包含大量与代码开发无关的内容。</p><h3 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h3><p>三者在核心功能上基本一致，这也导致其基本的工作开发流程大同小异，接下来以GitHub为例介绍我所理解的开发流程：</p><ol><li>建立开发分支（比如dev）</li><li>开发人员Fork项目到个人账户下</li><li>Clone到本地后进行开发</li><li>每次修改文件前Fetch一下远程仓库保证文件一致</li><li>将本地修改Push到个人账户的对应仓库下</li><li>向团队项目发出Pull Request</li><li>团队负责人审核并同意Pull Request，相关修改正式进行Merge</li></ol><hr><h2 id="调研CI-CD工具"><a href="#调研CI-CD工具" class="headerlink" title="调研CI/CD工具"></a>调研CI/CD工具</h2><p>持续集成（Continuous Integration, CI）是指代码提交后在并入主分支前进行一系列测试与构建，从而降低引入BUG的概率。</p><p>持续部署（Continuous Delivery, CD）则是在CI的基础上更进一步，将推送的分支部署到产品环境中，实现持续的产品交付。</p><h3 id="热门的CI-CD工具"><a href="#热门的CI-CD工具" class="headerlink" title="热门的CI/CD工具"></a>热门的CI/CD工具</h3><h4 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h4><p>Jenkins是CI/CD领域<strong>最早最大的开源CI工具</strong>，是整个CI/CD领域的事实标准。正因为其长久的生命力，使得其插件市场极为丰富，并且提供了多种扩展版本的Jenkins，比如JenkinsX等。因此Jenkins可以免费地满足几乎所有CI/CD需求，允许从Git或SVN等多种VCS上拉取代码，但是代价是更加高昂的学习开销和更为繁琐的日常使用。</p><h4 id="Travis-CI"><a href="#Travis-CI" class="headerlink" title="Travis CI"></a>Travis CI</h4><p>Travis CI是一款<strong>软件即服务（SaaS）</strong>的CI系统，可以绑定在GitHub或Bitbucket的项目上，然后直接访问Travis CI的网站进行项目的持续集成，而不用自己来进行部署。这使得其更加方便的同时，也使其更加<strong>不可定制化</strong>，因此在企业应用中份额较少。</p><h4 id="GitLab-CI"><a href="#GitLab-CI" class="headerlink" title="GitLab CI"></a>GitLab CI</h4><p>GitLab CI的一大特点在于其免费开源且定制性强。其中引入了<strong>Runner概念</strong>，使得使用者可以自定义用于持续集成部署的机器，进而提供了更高的可定制性，深受企业用户的青睐。</p><p>GitLab CI内置在GitLab中，需要在仓库根目录下创建<code>.gitlab-ci.yml</code>文件，然后配置一个GitLab Runner用于执行<code>.yml</code>脚本。每次提交，GitLab会自动识别<code>.yml</code>文件然后使用Runner运行它。</p><p>在GitLab CI中，每个提交触发的行为集合称为Pipeline，每个Pipeline包含多个stage，stage对应job，而job下包含script用于描述具体执行的命令。</p><h4 id="GitHub-Action"><a href="#GitHub-Action" class="headerlink" title="GitHub Action"></a>GitHub Action</h4><p>GitHub Action中将CI/CD的操作内容称为Action，并且认为在不同的项目中，这种Action是极为类似的，因此<strong>允许开发者将Action写作独立脚本文件，从而让其他开发者引用</strong>，这极大地方便了社区用户编写CI/CD脚本。</p><p>开发者需要在<code>.github/workflows/</code>目录下存放<code>.yml</code>格式的文件，然后在文件中写明如何执行workflow。每个workflow都会在提交时被执行，主要包括触发条件（on）和行为（job），每个job包含多个step，每个step包含多条Action，并且可以通过use关键字引用外部Action。</p><h4 id="Gitee-Go"><a href="#Gitee-Go" class="headerlink" title="Gitee Go"></a>Gitee Go</h4><p>Gitee Go采用了Pipeline来描述它的构建过程，同时提供了制品库管理、主机管理等附属功能，使得整个CI/CD流程更加完善，提供了<strong>一条龙服务</strong>，但是其Gitee Go需要付费使用。</p><p>Gitee Go最让我影响深刻的是其<strong>非常友好的图形视图</strong>，可以清晰地查看和设置CI/CD的各个步骤与流程，每个流程对应一个脚本。Gitee Go提供了类似Github Action的预设定脚本来处理特定的情景，但是不是社区化的，而是Gitee给定的。</p><p>我进一步查看其代码视图的脚本格式，可以发现其结构基本和Github Action的一致，这降低了迁移学习的成本，但是也让我怀疑Gitee Go只单纯是Github Action的付费仿品。Gitee Go在国内这一大环境下一定程度上填补了Github留下的空白。</p><h4 id="解决方案对比总结"><a href="#解决方案对比总结" class="headerlink" title="解决方案对比总结"></a>解决方案对比总结</h4><div class="table-container"><table><thead><tr><th>解决方案</th><th>Jenkins</th><th>Travis CI</th><th>GitLab CI</th><th>GitHub Action</th><th>Gitee Go</th></tr></thead><tbody><tr><td>是否收费</td><td>否</td><td>否</td><td>否（社区版即可支持）</td><td>否</td><td>是</td></tr><tr><td>可定制化程度</td><td>很高</td><td>很低</td><td>中等</td><td>较高</td><td>较低</td></tr><tr><td>图形界面的使用体验</td><td>功能丰富（插件支持）</td><td>较单调，倚重代码</td><td>较单调，倚重代码</td><td>较单调，倚重代码</td><td>支持无代码操作</td></tr><tr><td>是否能提供一条龙服务</td><td>可以（插件支持）</td><td>仅CI/CD内容</td><td>可以（支持Runner定制）</td><td>仅CI/CD内容</td><td>可以（辅助功能）</td></tr><tr><td>使用体验是否便捷</td><td>繁琐</td><td>简单（软件即服务）</td><td>繁琐（需要部署）</td><td>简单（支持复用Action）</td><td>简单方便</td></tr><tr><td>预计的用户群体</td><td>Geek开发者和团队</td><td>个人开发者</td><td>IT企业开发团队</td><td>个人开源开发者</td><td>中国的个人开发者和非IT企业团队</td></tr></tbody></table></div><h3 id="解决方案一：采用Gitee-Go实现对Flask-Web后端的测试"><a href="#解决方案一：采用Gitee-Go实现对Flask-Web后端的测试" class="headerlink" title="解决方案一：采用Gitee Go实现对Flask Web后端的测试"></a>解决方案一：采用Gitee Go实现对Flask Web后端的测试</h3><p>基于Gitee Go对原来<a href="https://gitee.com/neumy/actune-flask">数据库大作业的Flask后端</a>进行在线测试</p><p>主要测试了其随机数生成模块，测试结果截图如下：</p><p><img src="/img/blog/SEGITEEGITFLASK.png" alt="gitee上的截图"></p><h3 id="解决方案二：采用Github-Action与Hexo的静态博客自动编译部署"><a href="#解决方案二：采用Github-Action与Hexo的静态博客自动编译部署" class="headerlink" title="解决方案二：采用Github Action与Hexo的静态博客自动编译部署"></a>解决方案二：采用Github Action与Hexo的静态博客自动编译部署</h3><p>基于Github Action对自己的静态博客进行持续部署。</p><p>Hexo是静态的框架，因此如果不使用CI/CD的情况下，需要手动构建和部署。</p><p>现在的解决方案是，<strong>采用一个项目A作为Hexo项目，然后利用Github Action进行自动构建与部署</strong>，然后自动部署到Github Page对应项目B中，免去了本地构建的麻烦。注意这里<strong>项目A不是github.io项目</strong>，而是专用于存储文档的。项目B才是github.io项目，可以视作部署环境。</p><p><a href="https://github.com/neumyor/neumyblog">用于存储代码和文档的项目A</a></p><p><a href="https://github.com/neumyor/neumyor.github.io">用于部署网站的项目B</a></p><p><img src="/img/blog/SEGITHUBGITACTIONPAGE.png" alt="github上的项目A自动构建过程截图"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>从Attention 到 MultiHeadAttention</title>
    <link href="/2022/02/24/Attention%20Self-Attention%20Multi-Head-Attention/"/>
    <url>/2022/02/24/Attention%20Self-Attention%20Multi-Head-Attention/</url>
    
    <content type="html"><![CDATA[<h1 id="从Attention-到-MultiHeadAttention"><a href="#从Attention-到-MultiHeadAttention" class="headerlink" title="从Attention 到 MultiHeadAttention"></a>从Attention 到 MultiHeadAttention</h1><h2 id="对Attention-的理解"><a href="#对Attention-的理解" class="headerlink" title="对Attention 的理解"></a>对Attention 的理解</h2><p>Attention的本质类似于我们人类的注意力机制，寄希望于<strong>将有限的注意力集中于重点上</strong>，从而节省资源以获得最为有效的信息。</p><p>那么对于神经网络来说，什么是注意力呢？而又如何分辨什么是重点？简单来说，Attention机制通过计算知识源中的各个部分与学习目标的相关性，来尽可能学习相关性最高的部分。</p><blockquote><p>图书馆（<strong>source</strong>）有很多书（<strong>value</strong>），而为了方便查找，图书馆为每本书进行了编号（<strong>key</strong>），然后给出一个编号区间的表，来映射编号与语义的关系，假设编号1~5为计算机、编号6~10为数学、编号11~15为护理学。当我们需要学习有关人工智能（<strong>query</strong>）的知识时，我们根据这张表去重点阅读1~10号，而对11~15号只进行粗略的浏览。</p><p>这样，我们就能在有限的时间中获得尽可能多的关于人工智能的知识</p></blockquote><p>Attention机制可以被描述为以下步骤：</p><ol><li><p>将query与source中已知的key进行相似度计算，获得每个key的权值</p></li><li><p>将权值进行归一化，以得到直接可用的权重（$d_k$是$QK^T$方阵的维度）</p><blockquote><p>假设 $Q,K$ 里的元素的均值为0，方差为1，那么$Q K^T$中元素的均值为0，方差为d. 当d变得很大时，$Q K^T$中的元素的方差也会变得很大，如果$QK^T$中的元素方差很大，那么$Softmax(QK^T)$的分布会趋于陡峭(分布的方差大，分布集中在绝对值大的区域)。总结一下就是$Softmax(QK^T)$的分布会和d有关。因此 $Softermax(QK^T)$ 中每一个元素除以$\sqrt d_k$后，方差又变为1。这使得$Softmax(QK^T)$的分布“陡峭”程度与d解耦，从而使得训练过程中梯度值保持稳定。                                                                                                                                                                                                                                                                                                                                                                                                  </p></blockquote></li><li><p>将权重和value进行<strong>带权求和</strong>，得到向量Attention value</p></li></ol><script type="math/tex; mode=display">\text { Attention value }(Q, K, V)=\operatorname{softmax}\left(\frac{Q K^{T}}{\sqrt{d_{k}}}\right) V</script><p>对于一段知识源，一次Attention获得了该知识源的一个表示空间，以Attention value的方式表示。</p><h2 id="Self-Attention"><a href="#Self-Attention" class="headerlink" title="Self-Attention"></a>Self-Attention</h2><p>然而我们再思考一个问题，对于一段文本，究竟什么是它的query、什么是它的key、什么又是它的value呢？</p><p>假设我们的source是这样一段文本“Water is toxic”</p><p>当我们处理”Water”这个词时，将”Water“作为当前搜索的query，与其他词对应的key向量进行相似度计算。依次，我们用同样的方法计算剩下的两个单词。</p><p>Self-Attention认为(Q, K, V)均来自于source的词向量，即“Water is toxic”这一句话所生成的词向量，因此三者应该在生成机制上是一致的。因此定义了三个相互独立的权重矩阵（作为训练时的需要学习的参数），用于与输入的词向量相乘获得三个矩阵，分别作为Q、K、V。</p><p>详细内容查看<a href="https://zhuanlan.zhihu.com/p/410776234">超详细图解Self-Attention)</a>，非常详细而且易懂。</p><h2 id="Multi-Head-Attention"><a href="#Multi-Head-Attention" class="headerlink" title="Multi-Head Attention"></a>Multi-Head Attention</h2><p>Multi-Head Attention的一个基本思想在于，我们试图通过多个Attention来建立对同一个知识源的多个不同的注意力关系判断。这就好比让多个人来同时思考一个问题，不同的人看待问题的方式不一样，因此让多个人一起能够更好地找到这个问题相关的知识点。</p><p>从机制上，其相当于多个Self-Attention过程的融合。假设有n个Head：</p><ol><li>每个Head对应三个权重矩阵用于从输入向量中计算(Q, K, V)</li><li>每个Head根据自己的(Q, K, V)根据Attention过程计算得出Attention value向量。n个Head一共有n个Attention value。</li><li>将这n个Attention value向量连接起来，乘以一个权重矩阵，以使其转变为与输入向量大小相同的矩阵</li></ol><p>参考：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/266448080">Multi-Head Attention</a></li><li><a href="https://zhuanlan.zhihu.com/p/47282410">Attention机制详解（二）——Self-Attention与Transformer - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/91839581">一文看懂 Attention（本质原理+3大优点+5大类型） - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/410776234">超详细图解Self-Attention - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/109983672">拆 Transformer 系列二：Multi- Head Attention 机制详解 - 知乎 (zhihu.com)</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>GBDT</title>
    <link href="/2022/01/02/GDBT%20and%20Boosting/"/>
    <url>/2022/01/02/GDBT%20and%20Boosting/</url>
    
    <content type="html"><![CDATA[<h1 id="GBDT-Gradient-Boosting-Decision-Tree"><a href="#GBDT-Gradient-Boosting-Decision-Tree" class="headerlink" title="GBDT-Gradient Boosting Decision Tree"></a>GBDT-Gradient Boosting Decision Tree</h1><p>[TOC]</p><blockquote><p>参考资料:</p><ol><li><a href="https://www.cnblogs.com/ModifyRong/p/7744987.html">https://www.cnblogs.com/ModifyRong/p/7744987.html</a></li><li><a href="https://www.cnblogs.com/bentuwuying/p/6667267.html">https://www.cnblogs.com/bentuwuying/p/6667267.html</a></li></ol></blockquote><h2 id="GBDT是什么？"><a href="#GBDT是什么？" class="headerlink" title="GBDT是什么？"></a>GBDT是什么？</h2><p>GBDT是<strong>传统机器学习算法</strong>中对真实分布拟合最好的几种算法之一，在各大数据挖掘竞赛中常常出现前几名都采用GBDT算法，直到深度学习算法如潮水般涌来……。GBDT可以用于<strong>回归</strong>任务，也可以用于<strong>分类</strong>任务，还可以<strong>筛选特征</strong>。</p><p>GBDT的核心思想是采用<strong>基函数的线性组合</strong>，不断减小训练过程得出的残差来实现数据的分类和回归。具体来说，GBDT将经历多轮迭代，每次迭代生成一个弱分类器，而<strong>每个分类器在上一轮分类器的残差基础上进行训练</strong>。</p><blockquote><p>弱分类器：复杂度不高，通常具有低方差和高偏差。</p><p>方差和偏差：偏差描述了分类器在训练数据上预测的准确度。方差描述了分类器中不同迭代情况下的预测精度变化程度。通常来说，模型越复杂，对训练数据的拟合程度越高，偏差越低，但是方差会越高。</p></blockquote><p><img src="https://img2018.cnblogs.com/blog/891145/201811/891145-20181107135620778-1378612597.png" alt="img" style="zoom:50%;" /></p><h2 id="GBDT的理论基础"><a href="#GBDT的理论基础" class="headerlink" title="GBDT的理论基础"></a>GBDT的理论基础</h2><p>当我们试图估计一个有参数模型$F$时，设$F$的参数集合为$P$，那么我们将$F$视作一系列带参数的函数的线性组合：</p><script type="math/tex; mode=display">F(\bold x;P) = \sum_{m=1}^M\beta_mh(\bold x;a_m)</script><p>其中$a_m\in P$，$\beta$是权重参数。</p><p>通常来说，我们采用梯度下降方法来优化参数集合$P$，即：</p><script type="math/tex; mode=display">梯度\bold g_m=[\frac{\partial L(P)}{\partial P}]_{P=P_{m-1}}\\梯度下降步长\bold p_m=-\rho_m \bold g_m\\ where\ \rho_m=\underset{\rho}{\arg\min} L(P-\rho\bold g_m)</script><p>因此对应于第m次迭代，步长是$\bold p<em>m$，因此$P</em>{m}=\sum_{i=0}^{m}\bold p_i$，即对应第m次迭代的模型。<strong>从形式上看，我们用第m-1次迭代的模型的参数计算出第m次迭代时的梯度$\bold g_m$，然后利用这个梯度得出新的步长$\bold p_m$，由此计算出新的第m次迭代模型$P_m$</strong></p><p>而对于一个<strong>无参数模型</strong>，我们将每个数据点$\bold x_i$处的函数值$F(\bold x_i)$看作这个函数的参数，我们用有限个离散点${F(\bold x_i)}_1^N$来描述它们，因此上述梯度下降可以被描述为：</p><script type="math/tex; mode=display">梯度g_m(\bold x)=E_y\left[\frac{\partial L(y,F(\bold x))}{\partial F(\bold x)}|\bold x\right]_{F(\bold x)=F_{m-1}(\bold x)}\\梯度下降步长f_m(x)=\rho_m g_m(x) \\\rho_m=\underset{\rho}{\arg\min}\ E_{y,\bold x}\ L(y,F_{m-1}(\bold x)-\rho g_m(\bold x))</script><p>同样的，第m次迭代的模型$F^*(\bold x)=\sum_{i=0}^Mf_i(x)$</p><blockquote><p>$E_{y,\bold x}$这种数学期望带下标的符号的含义，可参考这篇文章<a href="https://www.zhihu.com/question/305642751">点我</a></p></blockquote><p>而<strong>GBDT的每次迭代就是上述的一次迭代过程</strong>，我们将弱分类器视作上述无参数模型$F$。弱分类器通常采用<strong>分类回归树</strong>，其复杂度会做适当限制以实现低方差的要求。GBDT最终通过加权求和的方式将多个弱分类器结合在一起实现总分类器，这就是GBDT中Boosting的由来。注意，Gradient Boosting<strong>对采用什么样的弱分类器来说是完全独立的</strong>，</p><blockquote><p>分类回归树（CART）：<a href="https://blog.csdn.net/weixin_30618985/article/details/95788433">参考资料</a></p></blockquote><p>每个弱分类器在逻辑上拟合的目标值是一个梯度，其可以被描述为：</p><script type="math/tex; mode=display">\hat{g_i}(\bold x_k) = -\frac{\partial L}{\partial F(\bold x_k)}|_{F=F_i}\ for\ k=1,2,3,...,N</script><p>其中$L$表示损失函数$Loss(F(\bold x_i), y_i)$，$F(\bold x)$表示样本$\bold x$的预测值。$i$表示了不同迭代次数，$F_i$对应不同迭代阶段的弱分类器，注意这里求的梯度是<strong>将每个数据点$\bold x_k$处的函数值$F(\bold x_k)$视作该弱分类器的一个参数</strong>，然后计算损失函数对这种形式的“参数”的梯度。这种的方法好处在于利用函数在各个点的取值来描述一个无参数的模型。</p><p>这里存在两个问题，一是k明显是一个离散值，因此我们在取$\bold x_k$时实际需要进行离散化的考虑；二是我们如何用N个离散值$F(\bold x_k)\ for\ k=1,2,3,…,N$来计算出拟合函数$g_i$，我们采用了决策树的方式来进行拟合，这也是GBDT中Decision Tree的由来。</p><blockquote><p>人们常说GBDT利用了残差来进行迭代，但实际上<strong>使用的是否是残差取决于你的损失函数如何定义</strong>，只有在使用平方差损失函数时，对应的梯度才是残差。如果采用的是绝对差值损失函数，那么最终得到的梯度实际上是一个符号函数而不是残差。</p></blockquote><p>而如果你问如何采用多个离散值来计算出弱分类器，这就其实是一个简单问题。假设你已知了k个样本的标记（即上述的k个离散值），那么建立一颗回归或者分类决策树是非常简单的。</p><p>最终经过m轮迭代，我们得到m个弱分类器，最终进行加权求和，权重与每轮残差有关。（你也可以直接相加，只是我觉得利用残差信息更合理一些）。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++常用数据结构</title>
    <link href="/2021/12/06/C++%20Basic%20Data%20Structure/"/>
    <url>/2021/12/06/C++%20Basic%20Data%20Structure/</url>
    
    <content type="html"><![CDATA[<h1 id="C-常用数据结构及其使用"><a href="#C-常用数据结构及其使用" class="headerlink" title="C++ 常用数据结构及其使用"></a>C++ 常用数据结构及其使用</h1><p>这是我最近在自学c++过程中，意识到自己对c++的数据结构尚不熟悉，因此搜罗来的各类资料并进行了自己的理解<br>[TOC]</p><h2 id="array-数组"><a href="#array-数组" class="headerlink" title="array 数组"></a>array 数组</h2><p>array在功能上是为了弥补传统C语言数组的越界问题，而由C++提出的更为安全的数组容器。</p><h3 id="array的初始化"><a href="#array的初始化" class="headerlink" title="array的初始化"></a>array的初始化</h3><p>数组array类是一个<strong>严格固定长度</strong>的容器，这意味着在声明时就需要声明长度。</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs c++">array&lt;<span class="hljs-type">int</span>,8&gt; <span class="hljs-number">8b</span>yteslongarray;<br></code></pre></td></tr></table></figure><p>array是一个严格线性的容器，在物理上也是线性排列，可以通过偏移指针来访问元素，访问耗时恒定。</p><h3 id="array的使用"><a href="#array的使用" class="headerlink" title="array的使用"></a>array的使用</h3><h4 id="迭代器的使用"><a href="#迭代器的使用" class="headerlink" title="迭代器的使用"></a>迭代器的使用</h4><p>array是一个可以通过迭代器iterator进行遍历的容器，可以通过以下方式获取和使用迭代器：</p><ul><li><p><strong>begin()</strong>:获取数组开头位置的迭代器</p></li><li><p><strong>end()</strong></p></li><li><p><strong>rbegin()</strong>：获取数组尾部的迭代器，且反向迭代</p></li><li><p><strong>rend()</strong></p></li><li><p>cbegin()：获取一个const的迭代器对象，<strong>无法通过const iterator去改变一个对象的值！</strong></p></li><li><p>cend()</p></li><li><p>crbegin()</p></li><li><p>crend()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = arr.<span class="hljs-built_in">rbegin</span>();it!=arr.<span class="hljs-built_in">crend</span>();++it)&#123;<br>cout &lt;&lt; *it &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="数据的访问"><a href="#数据的访问" class="headerlink" title="数据的访问"></a>数据的访问</h4><p>array是严格定长的，允许通过size()、empty()和max_size()进行容量的访问。（我不清楚max_size的作用）。</p><p>你可以通过多种方法访问一个array的数据对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">array[<span class="hljs-number">1</span>];<br>array.<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>);<br>array.<span class="hljs-built_in">front</span>();<br>array.<span class="hljs-built_in">back</span>(); <br>array.<span class="hljs-built_in">data</span>(); <span class="hljs-comment">// 获取指向第一个元素的指针</span><br></code></pre></td></tr></table></figure><p>注意array是物理上连续的，因此获取指针后可以通过跳转指针地址获取对象（但是出于安全考虑最好不要这样做）</p><p>array支持fill来进行内容的填充（不知道初始化时是否会fill全为0），还可以使用swap来交换指向的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">array.<span class="hljs-built_in">fill</span>(<span class="hljs-string">&quot;wanted value&quot;</span>);<br>arrayA.<span class="hljs-built_in">swap</span>(arrayB);<br></code></pre></td></tr></table></figure><hr><h2 id="vector-向量"><a href="#vector-向量" class="headerlink" title="vector 向量"></a>vector 向量</h2><p>vector是向量类型，是C++中重要的容器对象。其实质上也是采用数组进行实现，需要连续的存储空间，当数据极大时会导致分配内存上的困难。同时vector的优势在于智能管理，更加安全的同时还提供了大量的现有函数，支持自动增长。</p><h3 id="vector的多种初始化方式"><a href="#vector的多种初始化方式" class="headerlink" title="vector的多种初始化方式"></a>vector的多种初始化方式</h3><p>vector真是一个功能丰富的类呢（笑）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">999</span>)</span></span>; <span class="hljs-comment">// 声明一个999个整数的vector</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">666</span>,<span class="hljs-number">2</span>)</span></span>; <span class="hljs-comment">// 声明一个666个整数的vector并全部初始化为2</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">c</span><span class="hljs-params">(b)</span></span>; <span class="hljs-comment">// 将b整体复制性赋值给c</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">d</span><span class="hljs-params">(c.begin(),c.end()<span class="hljs-number">-4</span>)</span></span>; <span class="hljs-comment">// 利用始末迭代器构造</span><br><span class="hljs-type">int</span> array[<span class="hljs-number">100</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br><span class="hljs-type">int</span>* pointer = array+<span class="hljs-number">1</span>;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">e</span><span class="hljs-params">(pointer,pointer+<span class="hljs-number">3</span>)</span></span>; <span class="hljs-comment">// 利用指针间连续空间进行构造</span><br></code></pre></td></tr></table></figure><h3 id="vector的操作方式"><a href="#vector的操作方式" class="headerlink" title="vector的操作方式"></a>vector的操作方式</h3><h4 id="vector元素访问与更改"><a href="#vector元素访问与更改" class="headerlink" title="vector元素访问与更改"></a>vector元素访问与更改</h4><p>vector支持使用[ ]进行访问，还可以通过front和back获取特殊位置元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">v[<span class="hljs-number">4</span>]; <span class="hljs-comment">// 注意下标支持获取值，但是只支持获取size范围内的元素引用，试图获取一个没有声明大小的或者size访问外的元素将会导致错误！</span><br>v.<span class="hljs-built_in">at</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">// at稍微安全一点，因为其会返回错误信息指明访问非法</span><br>v.<span class="hljs-built_in">front</span>();<br>v.<span class="hljs-built_in">back</span>();<br>v.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">// 迭代器是最推荐的方法，因为迭代器实现了一个泛化的指针，具有更强的泛化性</span><br>v.<span class="hljs-built_in">end</span>(); <span class="hljs-comment">// 注意这个迭代器没有指向任何有效元素，其实际上指向最后一个元素后面的一个位置</span><br></code></pre></td></tr></table></figure><p>vector的元素操作方法极其丰富：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">v.<span class="hljs-built_in">assign</span>(b.<span class="hljs-built_in">begin</span>(),b.<span class="hljs-built_in">end</span>()<span class="hljs-number">-3</span>); <span class="hljs-comment">// 将b的第一个到倒数第4个字符赋值给v</span><br>v.<span class="hljs-built_in">assign</span>(<span class="hljs-number">4</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">// 给v赋值为4个连续的2</span><br><span class="hljs-comment">/* 注意assign会覆盖原有所有数据！*/</span><br>v.<span class="hljs-built_in">insert</span>(v.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>,<span class="hljs-number">5</span>); <span class="hljs-comment">// 在v的第二个元素位置插入一个5（使得v[1]==5）</span><br>v.<span class="hljs-built_in">insert</span>(v.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>); <span class="hljs-comment">// 在v的第二个元素位置插入4个6</span><br>v.<span class="hljs-built_in">insert</span>(v.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>,b,b+<span class="hljs-number">3</span>); <span class="hljs-comment">// 在v的第二个元素后插入b数组的前3个元素</span><br><br>v.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 删除最后一个元素（注意这个没有返回值！）</span><br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// 向v最后插入一个5</span><br><br>v.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">// 清除所有元素</span><br>v.<span class="hljs-built_in">erase</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">3</span>); <span class="hljs-comment">// 删除v的前三个元素</span><br></code></pre></td></tr></table></figure><h4 id="vector的容量操作"><a href="#vector的容量操作" class="headerlink" title="vector的容量操作"></a>vector的容量操作</h4><p>vector是具<strong>有动态拓展性</strong>的，但是也支持用户手动干预其容量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">a.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 获取vector长度</span><br>a.<span class="hljs-built_in">capacity</span>(); <span class="hljs-comment">// 注意容量总是大于等于长度!</span><br><br>a.<span class="hljs-built_in">empty</span>();<br><br>a.<span class="hljs-built_in">resize</span>(<span class="hljs-number">100</span>); <span class="hljs-comment">// 限制长度为100，空余位值随机！</span><br>a.<span class="hljs-built_in">resize</span>(<span class="hljs-number">100</span>,<span class="hljs-number">3</span>); <span class="hljs-comment">// 限制长度为100，空余位补3</span><br>a.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 手动扩容为1000，以防止系统自动多次扩容带来的性能损耗</span><br></code></pre></td></tr></table></figure><h4 id="vector的奇技淫巧"><a href="#vector的奇技淫巧" class="headerlink" title="vector的奇技淫巧"></a>vector的奇技淫巧</h4><p>vector作为一个极其重要的类，其集成了多种性能较高的算法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">v.<span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>()) <span class="hljs-comment">// 从小到大排列</span><br>v.<span class="hljs-built_in">reverse</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>()<span class="hljs-number">-3</span>) <span class="hljs-comment">// 翻转</span><br><span class="hljs-built_in">copy</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),b.<span class="hljs-built_in">begin</span>()) <span class="hljs-comment">// 把v从b的开头开始复制覆盖原有元素</span><br><span class="hljs-built_in">find</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>(),<span class="hljs-string">&quot;target&quot;</span>) <span class="hljs-comment">// 在a中查找特定元素</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_odd</span><span class="hljs-params">(T a)</span></span>;<br>v.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">remove_if</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),is_odd), array.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 在v中按照is_odd函数删除符合要求的元素</span><br></code></pre></td></tr></table></figure><hr><h2 id="deque-双向队列"><a href="#deque-双向队列" class="headerlink" title="deque 双向队列"></a>deque 双向队列</h2><p>deque双向队列，支持两端操作。<strong>vector是单向开口的内存空间</strong>，这意味着什么呢？意味着如果你在vector头部插入一个元素，那么会慢得离谱（这个操作是合法的但不是推荐的）。而deque则是更加好的选择，<strong>你可以在头尾很快地进行元素操作</strong>。相应的，其<strong>占用内存会更多</strong>。实际上deque包括两级结构，一级类似于vector，一级则是专门维护首地址。</p><h3 id="deque的初始化"><a href="#deque的初始化" class="headerlink" title="deque的初始化"></a>deque的初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">d</span> <span class="hljs-params">(a.begin(),a.end())</span></span>;<br><span class="hljs-function">deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">d</span> <span class="hljs-params">(a,a+<span class="hljs-number">3</span>)</span></span>;<br><span class="hljs-function">deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">d</span> <span class="hljs-params">(<span class="hljs-number">5</span>,<span class="hljs-number">8</span>)</span> <span class="hljs-comment">// 初始化为5个8</span></span><br><span class="hljs-function">deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">d</span> <span class="hljs-params">(anotherd)</span></span>; <span class="hljs-comment">// 拷贝复制</span><br></code></pre></td></tr></table></figure><h3 id="deque操作"><a href="#deque操作" class="headerlink" title="deque操作"></a>deque操作</h3><h4 id="deque赋值"><a href="#deque赋值" class="headerlink" title="deque赋值"></a>deque赋值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">d.<span class="hljs-built_in">assign</span>(a.<span class="hljs-built_in">begin</span>(),b.<span class="hljs-built_in">end</span>());<br>d.<span class="hljs-built_in">assign</span>(<span class="hljs-number">5</span>,<span class="hljs-number">8</span>);<br>d.<span class="hljs-built_in">swap</span>(anotherd);<br></code></pre></td></tr></table></figure><h4 id="deque特色"><a href="#deque特色" class="headerlink" title="deque特色"></a>deque特色</h4><p>我们说过，deque和vector的区别在于对双端操作的支持更好，而且我们能发现，<strong>deque比vector多了头部操作函数</strong>，除此之外没有特别明显的使用功能区别。(ps：deque还是一个没有容量概念的容器，因此和vector不同的一点在于，vector在空间不够的时候会申请一个新的空间再经过复制和释放旧空间的过程，但是deque会直接将新空间连接到旧空间后。因此deque没有reserve空间的需要)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">d.<span class="hljs-built_in">push_front</span>(element); <span class="hljs-comment">// 向头部添加一个元素</span><br>d.<span class="hljs-built_in">pop_front</span>(element); <span class="hljs-comment">// 删头部元素</span><br></code></pre></td></tr></table></figure><hr><h2 id="list-链表"><a href="#list-链表" class="headerlink" title="list 链表"></a>list 链表</h2><p>list是一个顺序容器，其通过链表实现，主要优势在于<strong>快速的插入和删除</strong>。</p><p>在功能上，vector、deque、list三者是经常被提及的选择对象，以下列出三者使用场景的不同。</p><ul><li><p>vector：大量随机访问需求 &amp;&amp; 插入删除多在尾部</p></li><li><p>list：少量访问需求 &amp;&amp; 大量插入和删除需求</p></li><li><p>deque：大量访问需求 &amp;&amp; 大量插入和删除需求 &amp;&amp; 对内存要求不高</p></li></ul><h3 id="list的初始化"><a href="#list的初始化" class="headerlink" title="list的初始化"></a>list的初始化</h3><p>list的初始化与vector类似，在此按下不表</p><h3 id="list的操作"><a href="#list的操作" class="headerlink" title="list的操作"></a>list的操作</h3><p>list的操作与vector略有不同，因为其链表的性质，<strong>合并和拆分的功能较为突出</strong>。另外也注意到list的<strong>有序性要求</strong>。注意list没有随机迭代访问器，因此其sort函数是自己定义的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">list.<span class="hljs-built_in">sort</span>(); <span class="hljs-comment">// 默认升序排序</span><br>list.<span class="hljs-built_in">sort</span>(<span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;()); <span class="hljs-comment">// 改为降序排序</span><br><br>l1.<span class="hljs-built_in">merge</span>(l2); <span class="hljs-comment">// merge要求两个链表都是有序的，默认升序</span><br>l1.<span class="hljs-built_in">merge</span>(l2,<span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;()); <span class="hljs-comment">// 改为降序排序</span><br><span class="hljs-comment">/* merge后l1为合并结果，l2为空 */</span><br><br>l1.<span class="hljs-built_in">splice</span>(it1,l2); <span class="hljs-comment">// 将l2全部剪切并接到it1位置后面，l2为空，it1指向的字符不变，it1-l1.begin()增加了</span><br>l1.<span class="hljs-built_in">splice</span>(it1,l2,it2); <span class="hljs-comment">// 将l2的it2位置字符剪切并接到l1的it1位置（使其成为it1指向对象）</span><br>l1.<span class="hljs-built_in">splice</span>(it1,l2,l2.<span class="hljs-built_in">begin</span>(),l2.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">2</span>); <span class="hljs-comment">// 将l2前三个字符剪切并接到l1的it1后</span><br></code></pre></td></tr></table></figure><hr><h2 id="map-表"><a href="#map-表" class="headerlink" title="map 表"></a>map 表</h2><p>map是我们所讲到的第一个关联容器，是一个对“映射”这种逻辑关系的支持，提供一对一的存储。map这种数据结构<strong>有两种实现</strong>：其一是<strong>基于红黑树的map</strong>，其二是<strong>基于hash表的unorder_map</strong>。前者的数据有序性更好，红黑树会对数据进行自动排序，但是占用空间大；后者对查找的支持更好，但是对于复杂操作的时间效率不够好。这两种的<strong>操作完全一样，只是底层不同</strong>！</p><h3 id="map的数据操作"><a href="#map的数据操作" class="headerlink" title="map的数据操作"></a>map的数据操作</h3><p>map有最主要的操作是“插入”，即插入键值对，具有三种插入方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;T,T&gt;(a,b));<br>map.<span class="hljs-built_in">insert</span>(map&lt;T,T&gt;::<span class="hljs-built_in">value_type</span>(a,b));<br><span class="hljs-comment">// insert不会覆盖原来的值</span><br>map[a]=b;<br><span class="hljs-comment">// 采用下标会覆盖原有的值</span><br></code></pre></td></tr></table></figure><p>map的数据查找<strong>比较反人类！</strong>，主要的方法为find</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">iter = map.<span class="hljs-built_in">find</span>(a);<br><span class="hljs-keyword">if</span>(iter!=map.<span class="hljs-built_in">end</span>()) find it!<br><span class="hljs-comment">// find返回的是对应位置的迭代器，没找到就会返回end()，不对应任何元素</span><br></code></pre></td></tr></table></figure><p>map的数据删除有两种方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> flag = map.<span class="hljs-built_in">erase</span>(a); <span class="hljs-comment">// 删除成功返回1，否则返回0</span><br>map.<span class="hljs-built_in">erase</span>(map.<span class="hljs-built_in">begin</span>(),map.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 清空map</span><br></code></pre></td></tr></table></figure><hr><h2 id="set-对"><a href="#set-对" class="headerlink" title="set 对"></a>set 对</h2><p>set是我们谈到的第二个关联容器，可以看出，关联容器不支持顺序容器的关于位置的操作（因为实际上没有位置的概念）。set中每个元素只是一个关键字，而与map中的键值对区别开来。</p><p>set的关联容器包括两大类四种：</p><ul><li><p>set：采用高效的平衡检索二叉树：红黑树</p><ul><li>unordered_set：基于hash函数实现的set</li></ul></li><li><p>multiset：支持关键字重复出现的set</p><ul><li>unordered_multiset</li></ul></li></ul><p>set的<strong>主要作用在于查询</strong>，即查询在该结构中存在特定关键字。set的元素会<strong>默认升序排列</strong>（默认比较函数为less\<int\>）</p><h3 id="set的初始化"><a href="#set的初始化" class="headerlink" title="set的初始化"></a>set的初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> * a = &#123;<span class="hljs-number">12</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>array&lt;<span class="hljs-type">int</span>&gt; b &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-function">set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s</span> <span class="hljs-params">(a,a+<span class="hljs-number">3</span>)</span></span>; <span class="hljs-comment">// 使用数组初始化</span><br><span class="hljs-function">set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s</span> <span class="hljs-params">(b.begin(),b.end())</span></span>; <span class="hljs-comment">// 使用迭代器初始化，很好理解，因为迭代器就是更加泛化的指针</span><br>set&lt;<span class="hljs-type">int</span>&gt; s &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;; <span class="hljs-comment">// 使用初始化列表初始化</span><br></code></pre></td></tr></table></figure><h3 id="set的使用"><a href="#set的使用" class="headerlink" title="set的使用"></a>set的使用</h3><p>首先，set支持一般的迭代器，因此你可以利用迭代器的连续变化来获取set内的值（这里体现了迭代器的泛化性，因为set实际上不是顺序存储的，但是利用起迭代器来和顺序容器完全一样）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (it=s.<span class="hljs-built_in">begin</span>();it!=s.<span class="hljs-built_in">end</span>();it++)&#123;<br>cout &lt;&lt; *it &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>其次，我们说过set的主要作用在于寻找元素是否存在，因此传统艺能不能丢（指count和find）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">s.<span class="hljs-built_in">count</span>(<span class="hljs-string">&quot;target&quot;</span>); <span class="hljs-comment">// 返回0或者1,0表示不存在</span><br>s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;target&quot;</span>); <span class="hljs-comment">// 返回迭代器，不存在则返回s.end()</span><br></code></pre></td></tr></table></figure><p>set的元素增删采用insert和erase实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">s.<span class="hljs-built_in">erase</span>(<span class="hljs-string">&quot;target&quot;</span>);<br>s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>(),s.<span class="hljs-built_in">being</span>()+<span class="hljs-number">3</span>);<br>s.<span class="hljs-built_in">insert</span>(<span class="hljs-string">&quot;me&quot;</span>);<br>s.<span class="hljs-built_in">insert</span>(vector.<span class="hljs-built_in">begin</span>(),vector.<span class="hljs-built_in">end</span>());<br><span class="hljs-comment">// erase和insert支持传入迭代器区间操作</span><br></code></pre></td></tr></table></figure><hr><h2 id="stack-栈"><a href="#stack-栈" class="headerlink" title="stack 栈"></a>stack 栈</h2><h3 id="如何初始化一个stack？"><a href="#如何初始化一个stack？" class="headerlink" title="如何初始化一个stack？"></a>如何初始化一个stack？</h3><p>stack 容器适配器的模板有两个参数。<strong>第一个参数是存储对象的类型</strong>，<strong>第二个参数是底层容器的类型</strong>。stack<T> 的底层容器默认是 deque<T> 容器，因此模板类型其实是 stack<typename T, typename Container=deque<T>&gt;。通过指定第二个模板类型参数，可以使用任意类型的底层容器，<strong>只要它们支持 back()、push_back()、pop_back()、empty()、size() 这些操作</strong>。下面展示了如何定义一个使用 list<T> 的堆栈：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::stack&lt;T,std::list&lt;T&gt;&gt; stackOnList;<br></code></pre></td></tr></table></figure><p>初始化一个堆栈时，<strong>不能在初始化列表{}中用对象来初始化</strong>，但是可以用另一个容器来初始化，只要<strong>堆栈的底层容器类型和这个容器的类型相同</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::list&lt;T&gt; l &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>std::stack&lt;<span class="hljs-type">int</span>, std::list&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">mystack</span>(l);<br></code></pre></td></tr></table></figure><p>不过stack<strong>支持拷贝构造</strong>，这意味着在初始化列表使用一个stack能够制造一个副本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::stack&lt;<span class="hljs-type">int</span>, std::list&lt;<span class="hljs-type">int</span>&gt;&gt; anotherstack &#123;mystack&#125;;<br></code></pre></td></tr></table></figure><h3 id="stack类的操作"><a href="#stack类的操作" class="headerlink" title="stack类的操作"></a>stack类的操作</h3><p>stack 是一类存储机制简单、所提供操作较少的容器。下面是 stack 容器可以提供的一套完整操作：</p><ul><li><p><strong>top()</strong>：返回一个栈顶元素的引用，类型为 T&amp;。如果栈为空，返回值未定义。</p></li><li><p><strong>push(const T&amp; obj)</strong>：可以将对象副本压入栈顶。这是通过调用底层容器的 push_back() 函数完成的。</p></li><li><p><strong>push(T&amp;&amp; obj)</strong>：以移动对象的方式将对象压入栈顶。这是<strong>通过调用底层容器的有右值引用参数的 push_back() 函数完成的</strong>。</p></li><li><p><strong>pop()</strong>：弹出栈顶元素。</p></li><li><p><strong>size()</strong>：返回栈中元素的个数。</p></li><li><p><strong>empty()</strong>：在栈中没有元素的情况下返回 true。</p></li><li><p><strong>emplace()</strong>：用<strong>传入的参数调用构造函数</strong>，在栈顶生成对象。这意味着传入T对应的构造函数所需参数即可在栈顶生成对象，而不需要先生成一个T对象再push进去，更节省内存。</p></li><li><p><strong>swap(stack<T> &amp; other_stack)</strong>：将当前栈中的元素和参数中的元素交换。参数所包含元素的类型必须和当前栈的相同。对于 stack 对象有一个特例化的全局函数 swap() 可以使用。注意这<strong>实质上交换了的是指向的内存位置</strong>，因此即使size不同也可以交换。</p></li></ul><p>同时stack也<strong>支持多种运算符</strong>。stack<T> 模板也定义了复制和移动版的 <strong>operator=()</strong> 函数，因此可以将一个 stack 对象赋值给另一个 stack 对象。stack 对象有<strong>一整套比较运算符</strong>。比较运算通过字典的方式来比较底层容器中相应的元素。字典比较是一种用来对字典中的单词进行排序的方式。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>OS文件系统与驱动设计（个人OS课设笔记节选）</title>
    <link href="/2021/07/06/OS%20Lab5%20File%20System/"/>
    <url>/2021/07/06/OS%20Lab5%20File%20System/</url>
    
    <content type="html"><![CDATA[<h1 id="OS课程设计-文件系统的实现与驱动设计"><a href="#OS课程设计-文件系统的实现与驱动设计" class="headerlink" title="OS课程设计 文件系统的实现与驱动设计"></a>OS课程设计 文件系统的实现与驱动设计</h1><p>实验的目的在于：</p><ol><li>了解文件系统的基本概念和作用</li><li>了解普通磁盘的基本结构和读写方式</li><li>了解实现设备驱动的方法</li><li><strong>掌握并实现文件系统服务的基本操作</strong></li><li>了解微内核的基本设计思想和结构</li></ol><p>为了避免同志们坐享其成，所有代码均取自<a href="[login256/BUAA-OS-2019: 北航OS课课设代码 (github.com">login学长的开源代码</a>](<a href="https://github.com/login256/buaa-os-2019/))，为方便理解，做少量注释，可以理解该篇为Lab">https://github.com/login256/buaa-os-2019/))，为方便理解，做少量注释，可以理解该篇为Lab</a> 5任务导读（x</p><p>[TOC]</p><h2 id="什么是文件系统？"><a href="#什么是文件系统？" class="headerlink" title="什么是文件系统？"></a>什么是文件系统？</h2><p>文件系统的出现是为了更好地管理在不易失存储介质上存放的数据，而通常来说这种外部不易失的存储设备就是磁盘。文件系统将磁盘上的数据抽象化，使得用户能够很方便地访问数据而无需关心具体和磁盘之间的交互。</p><p>注意，<strong>文件系统是高度抽象性的</strong>，它是管理数据的抽象的界面，而背后实际的数据存储形式是对用户来说不可见的。因此，文件系统一方面需要面向复杂多样的数据存储媒介，一方面需要面向用户提供简洁统一的接口。</p><p>同时，<strong>文件系统也可以不仅是文件系统</strong>，诸如proc这样的虚拟文件系统还可以实现Windows中任务管理器的功能，这取决于你如何定义一个文件是什么。</p><h3 id="有关本次实验的具体问题"><a href="#有关本次实验的具体问题" class="headerlink" title="有关本次实验的具体问题"></a>有关本次实验的具体问题</h3><p><strong>本次实验中提到的文件系统既是指磁盘文件系统，又是指操作系统上的文件系统</strong>。注意，磁盘文件系统是在磁盘驱动器上而言的，而操作系统的文件系统是针对操作系统而言的，两者的<strong>结构即使一致，其在磁盘和内存上的表示也会有一定差异</strong>，需要注意区分。</p><p>本次我们需要分三步实现文件系统：</p><ol><li>实现磁盘的用户态驱动程序</li><li>实现磁盘上和操作系统上的文件系统结构，并在调用驱动程序的基础上实现文件系统操作相关函数</li><li>提供接口和机制使得用户态下也能够使用文件系统</li></ol><h3 id="一些基本概念的补充"><a href="#一些基本概念的补充" class="headerlink" title="一些基本概念的补充"></a>一些基本概念的补充</h3><p>为什么说操作系统和磁盘上文件系统不同也能进行正常使用：举例，Linux使用的是VFS文件系统，但是可以与Ext4等多种文件系统的磁盘驱动器正常通讯。理论上，磁盘文件系统不同的磁盘上，数据的组织方式不同，按统一的方式去访问肯定不行。但是Linux提出的VFS（Virtual Filesystem Switch）是一个虚拟的文件系统，其将其他不同文件系统分别进行解释，然后以统一的方式进行管理，由此实现了对于用户来说完全一致的效果。<strong>这恰恰反映了文件系统的抽象性</strong>。</p><p>磁盘驱动程序：<strong>位于操作系统中的一段代码</strong>，与操作系统高度相关，描述了对应磁盘驱动器的信息和提供操作接口。操作系统需要通过驱动程序才能与磁盘驱动器通信。</p><p>磁盘与磁盘驱动器：磁盘是一个物理结构，用于存储信息，而磁盘驱动器是用于控制磁盘旋转、读取的机构。操作系统需要通过驱动程序才能和磁盘驱动器交流，而磁盘驱动器再去磁盘上寻找对应信息。</p><h2 id="三点几嘞，写个磁盘驱动先啦"><a href="#三点几嘞，写个磁盘驱动先啦" class="headerlink" title="三点几嘞，写个磁盘驱动先啦"></a>三点几嘞，写个磁盘驱动先啦</h2><p>本次实验中我们使用<strong>内存映射I/O技术（MMIO）</strong>来实现一个IDE磁盘的驱动。IDE具体的意思是Integrated Driver Electronics，字面意思指这种磁盘的控制器和盘体集合在一起，但是SATA磁盘也是这样的结构，二者主要区别在于接口串行和并行。不过这和我们的实验没有什么关系。</p><p>另外需要说明的一点是，本次的驱动程序<strong>完全运行在用户态下</strong>，这是需要两个新的系统调用<code>sys_write_dev</code>和<code>sys_read_dev</code>支持的，它们实现了用户态下对设备的读写。</p><h4 id="sys-write-dev"><a href="#sys-write-dev" class="headerlink" title="sys_write_dev"></a>sys_write_dev</h4><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// lib/syscall_all.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sys_write_dev</span><span class="hljs-params">(<span class="hljs-type">int</span> sysno, u_int va, u_int dev, u_int len)</span><br>&#123;<br><span class="hljs-type">int</span> cnt_dev = <span class="hljs-number">3</span>; <span class="hljs-comment">// 支持三个设备</span><br>u_int dev_start_addr[] = &#123;<span class="hljs-number">0x10000000</span>, <span class="hljs-number">0x13000000</span>, <span class="hljs-number">0x15000000</span>&#125;; <span class="hljs-comment">// 每个设备对应的物理地址</span><br>u_int dev_length[] = &#123;<span class="hljs-number">0x20</span>, <span class="hljs-number">0x4200</span>, <span class="hljs-number">0x200</span>&#125;; <span class="hljs-comment">// 每个设备对应的空间长度</span><br>u_int target_addr = dev + <span class="hljs-number">0xa0000000</span>; <span class="hljs-comment">// 计算出对应的内核虚拟地址</span><br><span class="hljs-type">int</span> i;<br><span class="hljs-type">int</span> checked = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//do check:</span><br><span class="hljs-keyword">if</span> (va &gt;= ULIM)<br>&#123;<br><span class="hljs-keyword">return</span> -E_INVAL;<br>&#125;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; cnt_dev; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (dev_start_addr[i] &lt;= dev &amp;&amp; dev + len - <span class="hljs-number">1</span> &lt; dev_start_addr[i] + dev_length[i])<br>&#123;<br>checked = <span class="hljs-number">1</span>; <span class="hljs-comment">// 表示确认了往这个地址写是在允许范围内的</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (checked == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">return</span> -E_INVAL;<br>&#125;<br><br><span class="hljs-comment">//do copy</span><br>bcopy((<span class="hljs-type">void</span> *)va, (<span class="hljs-type">void</span> *)target_addr, len); <span class="hljs-comment">// 从va处向目标处复制，完成写入</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="sys-read-dev"><a href="#sys-read-dev" class="headerlink" title="sys_read_dev"></a>sys_read_dev</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// lib/syscall_lib.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sys_read_dev</span><span class="hljs-params">(<span class="hljs-type">int</span> sysno, u_int va, u_int dev, u_int len)</span><br>&#123;<br><span class="hljs-type">int</span> cnt_dev = <span class="hljs-number">3</span>;<br>u_int dev_start_addr[] = &#123;<span class="hljs-number">0x10000000</span>, <span class="hljs-number">0x13000000</span>, <span class="hljs-number">0x15000000</span>&#125;;<br>u_int dev_length[] = &#123;<span class="hljs-number">0x20</span>, <span class="hljs-number">0x4200</span>, <span class="hljs-number">0x200</span>&#125;;<br>u_int target_addr = dev + <span class="hljs-number">0xa0000000</span>;<br><span class="hljs-type">int</span> i;<br><span class="hljs-type">int</span> checked = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//do check:</span><br><span class="hljs-keyword">if</span> (va &gt;= ULIM)<br>&#123;<br><span class="hljs-keyword">return</span> -E_INVAL;<br>&#125;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; cnt_dev; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (dev_start_addr[i] &lt;= dev &amp;&amp; dev + len - <span class="hljs-number">1</span> &lt; dev_start_addr[i] + dev_length[i])<br>&#123;<br>checked = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (checked == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">return</span> -E_INVAL;<br>&#125;<br><br><span class="hljs-comment">//do copy</span><br>bcopy((<span class="hljs-type">void</span> *)target_addr, (<span class="hljs-type">void</span> *)va, len); <span class="hljs-comment">// 和sys_write_dev 唯一的不同</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="内存映射I-O-MMIO"><a href="#内存映射I-O-MMIO" class="headerlink" title="内存映射I/O MMIO"></a>内存映射I/O MMIO</h3><p>硬件设备上具有一些寄存器，CPU通过读写这些寄存器来和硬件设备进行通信，因此这些寄存器被称为<strong>I/O端口</strong>。而这些寄存器并不是直接以寄存器的方式展现给CPU的，而是<strong>映射到内存的某个位置</strong>。当CPU读写这块内存的时候，实际上读写了相应的I/O端口。而操作系统怎么知道不同的外设映射到具体哪个位置呢？实际上这需要在系统启动后，由BIOS告知。</p><p>在MIPS结构中，这种机制更为简单。其在kseg0和kseg1段里从硬件的层次可预知地实现了物理地址到内核虚拟地址的转换，这使得所有I/O设备都可以存放在这段空间里，并通过确定的映射关系计算出对应的物理地址。而我们<strong>用kseg1来进行转换，而不用kseg0</strong>，因为kseg0需要经过cache缓存，导致不可预知的问题。</p><p>进一步，在我们的实验中，模拟器中<strong>I/O设备的物理地址是完全固定的</strong>，我们的驱动程序就只需要对特定内核虚拟地址进行读写即可。</p><h3 id="驱动程序编写"><a href="#驱动程序编写" class="headerlink" title="驱动程序编写"></a>驱动程序编写</h3><p>由于驱动程序的编写实际上就是对特定地址进行读写，我们需要清楚两个主要问题：</p><ol><li>往哪里写？从哪里读？</li><li>读/写对应的数据的意义是什么？</li></ol><p>这两个是和硬件有关的，所幸的是指导书中已经给了出来，Gxemul中IDE磁盘的基址是0x13000000（注意这是物理地址）。</p><div class="table-container"><table><thead><tr><th>偏移量</th><th>说明</th></tr></thead><tbody><tr><td>0x0000</td><td>向这个地址写入的32位u_int，将指定下一次读/写操作相对于磁盘起始地址的偏移量的<strong>低32位</strong>（以字节计）</td></tr><tr><td>0x0008</td><td>向这个地址写入的32位u_int，将指定下一次读/写操作相对于磁盘起始地址的偏移量的<strong>高32位</strong>（以字节计）</td></tr><tr><td>0x0010</td><td>向这个地址写入的32位u_int，将指定具体的磁盘ID（本实验中这个值始终为0）</td></tr><tr><td>0x0020</td><td>向这个地址写入的8位u_char，将指定需要进行的操作类型，0为读，1为写</td></tr><tr><td>0x0030</td><td>从这个位置读取的8位u_char，将反映上一次操作的执行状态，0表示失败，否则为成功</td></tr><tr><td>0x4000 - 0x41ff</td><td>进行读操作时，当读取成功后，从这个区间读出的512个字节，将反映从指定位置读出的数据；进行写操作时，当写入成功，这512个字节将被写入指定位置</td></tr></tbody></table></div><p>当对其进行操作时，正如我们上文提到的，需要通过<strong>kseg1区进行地址转换</strong>，由此我们<strong>需要访问0xB3000000</strong>，从而利用kseg1区的地址转换机构成功访问0x13000000。由此我们成功解释了如何通过MIPS指令就能操作磁盘，接下来我们需要以此编写具体的操作函数。</p><h4 id="ide-write"><a href="#ide-write" class="headerlink" title="ide_write"></a>ide_write</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">ide_write</span><span class="hljs-params">(u_int diskno, u_int secno, <span class="hljs-type">void</span> *src, u_int nsecs)</span><br>&#123;<br>u_int offset_begin = secno * <span class="hljs-number">0x200</span>; <span class="hljs-comment">// 根据起始扇区号计算出起始偏移量，一个扇区512个字节</span><br>u_int offset_end = offset_begin + nsecs * <span class="hljs-number">0x200</span>; <span class="hljs-comment">// 根据读取扇区数量计算出终止偏移量</span><br>u_int offset = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化循环递增量</span><br>u_int dev_addr = <span class="hljs-number">0x13000000</span>;<br>u_char status = <span class="hljs-number">0</span>;<br>u_char write_value = <span class="hljs-number">1</span>;<br><br>writef(<span class="hljs-string">&quot;diskno: %d\n&quot;</span>, diskno);<br><br><span class="hljs-keyword">while</span> (offset_begin + offset &lt; offset_end) &#123;<br>        <span class="hljs-comment">// 每个循环操作512个字节，即一个扇区</span><br>u_int now_offset = offset_begin + offset;<br><span class="hljs-keyword">if</span> (syscall_write_dev((u_int)&amp;diskno, dev_addr + <span class="hljs-number">0x10</span>, <span class="hljs-number">4</span>) &lt; <span class="hljs-number">0</span>)<br>&#123;<br>user_panic(<span class="hljs-string">&quot;ide_write error!&quot;</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (syscall_write_dev((u_int)&amp;now_offset, dev_addr + <span class="hljs-number">0x0</span>, <span class="hljs-number">4</span>) &lt; <span class="hljs-number">0</span>)<br>&#123;<br>user_panic(<span class="hljs-string">&quot;ide_write error!&quot;</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (syscall_write_dev((u_int)(src + offset), dev_addr + <span class="hljs-number">0x4000</span>, <span class="hljs-number">0x200</span>) &lt; <span class="hljs-number">0</span>)<br>&#123;<br>user_panic(<span class="hljs-string">&quot;ide_write error!&quot;</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (syscall_write_dev((u_int)&amp;write_value, dev_addr + <span class="hljs-number">0x20</span>, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)<br>&#123;<br>user_panic(<span class="hljs-string">&quot;ide_write error!&quot;</span>);<br>&#125;<br>status = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (syscall_read_dev((u_int)&amp;status, dev_addr + <span class="hljs-number">0x30</span>, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)<br>&#123;<br>user_panic(<span class="hljs-string">&quot;ide_write error!&quot;</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (status == <span class="hljs-number">0</span>)<br>&#123;<br>user_panic(<span class="hljs-string">&quot;ide write faild!&quot;</span>);<br>&#125;<br>offset += <span class="hljs-number">0x200</span>;<br>&#125;<br><span class="hljs-comment">//writef(&quot;ide_write %x %s\n&quot;, offset_begin, src);</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="ide-read"><a href="#ide-read" class="headerlink" title="ide_read"></a>ide_read</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">ide_read</span><span class="hljs-params">(u_int diskno, u_int secno, <span class="hljs-type">void</span> *dst, u_int nsecs)</span><br>&#123;<br><span class="hljs-comment">// 0x200: the size of a sector: 512 bytes.</span><br>    <span class="hljs-comment">// 除了读写行为不同，其他逻辑和ide_write一致</span><br>u_int offset_begin = secno * <span class="hljs-number">0x200</span>;<br>u_int offset_end = offset_begin + nsecs * <span class="hljs-number">0x200</span>;<br>u_int offset = <span class="hljs-number">0</span>;<br>u_int dev_addr = <span class="hljs-number">0x13000000</span>;<br>u_char status = <span class="hljs-number">0</span>;<br>u_char read_value = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span> (offset_begin + offset &lt; offset_end) &#123;<br>u_int now_offset = offset_begin + offset;<br><span class="hljs-keyword">if</span> (syscall_write_dev((u_int)&amp;diskno, dev_addr + <span class="hljs-number">0x10</span>, <span class="hljs-number">4</span>) &lt; <span class="hljs-number">0</span>)<br>&#123;<br>user_panic(<span class="hljs-string">&quot;ide_read error!&quot;</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (syscall_write_dev((u_int)&amp;now_offset, dev_addr + <span class="hljs-number">0x0</span>, <span class="hljs-number">4</span>) &lt; <span class="hljs-number">0</span>)<br>&#123;<br>user_panic(<span class="hljs-string">&quot;ide_read error!&quot;</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (syscall_write_dev((u_int)&amp;read_value, dev_addr + <span class="hljs-number">0x20</span>, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)<br>&#123;<br>user_panic(<span class="hljs-string">&quot;ide_read error!&quot;</span>);<br>&#125;<br>status = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (syscall_read_dev((u_int)&amp;status, dev_addr + <span class="hljs-number">0x30</span>, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)<br>&#123;<br>user_panic(<span class="hljs-string">&quot;ide_read error!&quot;</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (status == <span class="hljs-number">0</span>)<br>&#123;<br>user_panic(<span class="hljs-string">&quot;ide read faild!&quot;</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (syscall_read_dev((u_int)(dst + offset), dev_addr + <span class="hljs-number">0x4000</span>, <span class="hljs-number">0x200</span>) &lt; <span class="hljs-number">0</span>)<br>&#123;<br>user_panic(<span class="hljs-string">&quot;ide_read error!&quot;</span>);<br>&#125;<br>offset += <span class="hljs-number">0x200</span>;<br>&#125;<br><span class="hljs-comment">//writef(&quot;ide_read %x %s\n&quot;, offset_begin, dst);</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="呐，文件系统始まる！"><a href="#呐，文件系统始まる！" class="headerlink" title="呐，文件系统始まる！"></a>呐，文件系统始まる！</h2><p>文件系统，从根本上来说是一种规范。我们实现的磁盘驱动只是往磁盘读写特定的二进制数据，而不管这些数据是如何组织的，也不管这些数据的意义是什么。而文件系统就是一套说明这些数据组织的逻辑，更实际一点，就是如何划分和解释磁盘的空间，这也是<strong>文件系统结构</strong>的根本意义。</p><p>我们的MOS的文件系统将磁盘按下面这种方式进行划分：</p><p><img src="img/blog/2028226-20210523220512737-1714373405.png" alt="磁盘划分情况"></p><p>我们将磁盘描述为若干个<strong>磁盘块（Block），每个Block大小为4KB</strong>。</p><p>对于N个磁盘块的磁盘，其<strong>第一个磁盘块用于启动和存放分区表</strong>，第二个磁盘块整个都被分给了<strong>超级块（super block）</strong>。它超级在哪里呢？其<strong>负责存放整个文件系统的基本信息：磁盘大小、根目录位置等</strong>。</p><h3 id="相关机制和数据结构设计"><a href="#相关机制和数据结构设计" class="headerlink" title="相关机制和数据结构设计"></a>相关机制和数据结构设计</h3><p><strong>这里课程组有一个锅，其指导书混淆了磁盘块（Block，4KB）、扇区（512B）和文件控制块（sizeof(struct File) = 256B）。如果你是学弟学妹的话，可以留意一下指导书有没有改</strong>。<del>我已经向助教提出了这个问题，学弟学妹们可以注意一下</del>。</p><h4 id="超级块-Super"><a href="#超级块-Super" class="headerlink" title="超级块 Super"></a>超级块 Super</h4><p>我们使用一个数据结构来描述超级块：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Super</span> &#123;</span><br>  u_int s_magic; <span class="hljs-comment">// Magic number: FS_MAGIC，用于识别文件系统类型</span><br>  u_int s_nblocks; <span class="hljs-comment">// 总磁盘块数量，MOS中为1024</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> <span class="hljs-title">s_root</span>;</span> <span class="hljs-comment">// 一个文件控制块，表示根目录位置</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>注意到虽然超级块的数据结构并不大，但是磁盘中整整分配给它了一整个磁盘块（4KB大小）。</p><h4 id="文件控制块-File"><a href="#文件控制块-File" class="headerlink" title="文件控制块 File"></a>文件控制块 File</h4><p>File就是我们定义的文件控制块：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> &#123;</span><br>  u_char f_name[MAXNAMELEN]; <span class="hljs-comment">// filename</span><br>  u_int f_size; <span class="hljs-comment">// file size in bytes</span><br>  u_int f_type; <span class="hljs-comment">// file type，分为FILE_REG（普通文件）和FILE_DIR（目录文件）</span><br>  u_int f_direct[NDIRECT]; <span class="hljs-comment">// 文件的直接指针，其数值表示磁盘中特定磁盘块号，NDIRECT = 10，即可代表至多10个磁盘块，共40KB的文件大小</span><br>  u_int f_indirect; <span class="hljs-comment">// 表示一个间接磁盘块的块号，其中存储了指向文件内容的磁盘块的直接指针（此处我们规定不使用间接磁盘块中的前10个直接指针）</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> *<span class="hljs-title">f_dir</span>;</span> <span class="hljs-comment">// 指向文件所属的目录文件</span><br>  u_char f_pad[BY2FILE - MAXNAMELEN - <span class="hljs-number">4</span> - <span class="hljs-number">4</span> - NDIRECT * <span class="hljs-number">4</span> - <span class="hljs-number">4</span> - <span class="hljs-number">4</span>]; <span class="hljs-comment">// 占位，为了使得一个struct File恰好占据256字节（BY2FILE = 256）</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>两个File结构体恰好占一个扇区。</p><h4 id="磁盘块管理位图-nbitblock"><a href="#磁盘块管理位图-nbitblock" class="headerlink" title="磁盘块管理位图 nbitblock"></a>磁盘块管理位图 nbitblock</h4><p>我们在Lab 5中使用位图法来管理磁盘块，这有别于使用链表法进行管理。在本实验中，<strong>相应位为1表示空闲，反之为占用</strong>。注意，我们在这里使用位图法，也就是每一位都是对应一个磁盘块的。而实际上<code>nbitblock</code>是一个字节数组，其中每个元素都是8位，称之为一个<strong>位图块</strong>。因此在初始化时，注意<strong>有的位图块（8位）的后面几个位不一定有实际的磁盘块与之对应</strong>，所以不能将其初始化为空闲。</p><h4 id="文件系统进程空间-与-块缓存机制"><a href="#文件系统进程空间-与-块缓存机制" class="headerlink" title="文件系统进程空间 与 块缓存机制"></a>文件系统进程空间 与 块缓存机制</h4><p>我们的<strong>文件系统是在用户空间内的一个进程</strong>，其拥有4GB的进程空间，而这个空间是我们实现和磁盘数据交流的一个重要中介。我们将所有磁盘块都按一定规则映射到这各进程空间内，而当我们需要往磁盘写数据时，就从这个进程空间取数据，而读数据时就往这个进程空间存放数据。</p><p>注意这个<strong>文件系统进程空间和传统的进程空间不同</strong>，其将DISKMAP~DISKMAP+DISKMAX（0x10000000~0x4fffffff）这一大段空间作为缓冲区，当对硬盘上特定磁盘块Block[id]进行读写时，其唯一对应于这块缓冲区中一块512字节的空间，需要写入的数据会存放在这块空间里等候写入，读出来的信息也会放在这块空间里等候发送给用户进程。这就是<strong>块缓存</strong>。</p><p>而这个进程空间本身又是由虚拟内存管理来实现的，每个block在没有被触发时只是在理论上占有一个虚拟空间，而当使用时会动态分配一个物理页给它（我们会发现一个磁盘块大小恰为一个物理页）。</p><p>由此我们的文件系统实际上与三个数据结构有较大联系：</p><ol><li>磁盘块管理位图 nbitblock</li><li>磁盘块中的文件控制块 File</li><li>文件系统进程空间映射关系（实际上是管理其的页表结构）</li></ol><h3 id="访问文件的中经历了什么？"><a href="#访问文件的中经历了什么？" class="headerlink" title="访问文件的中经历了什么？"></a>访问文件的中经历了什么？</h3><p>访问一个文件，首先要找到其对应的文件控制块结构。该过程首先需要经过从根目录文件的逐级查找。而找到对应文件控制块后，则可以通过其中的指针找到对应的磁盘块，从而利用驱动程序访问到指定数据。</p><p>而<strong>文件系统在我们的操作系统中作为独立的进程</strong>存在，其通过进程间IPC的方式来服务于用户进程，其为服务所开放的函数中存储在fs/serv.c中。用户进程需要调用user/file.c中的函数实现文件系统操作，而其底层调用user/fsipc.c中的函数来实现和文件系统进程的IPC。</p><h4 id="代码的分布和调用逻辑"><a href="#代码的分布和调用逻辑" class="headerlink" title="代码的分布和调用逻辑"></a>代码的分布和调用逻辑</h4><p><img src="img/blog/2028226-20210523220445682-418539770.png" alt="文件系统代码调用逻辑"></p><p>以打开一个文件并获取其数据为例，用户进程需要调用file.c中的<code>open</code>函数，其中调用了fsipc.c中的<code>fsipc_open</code>和<code>fsipc_map</code>。</p><p>用户进程调用<code>fsipc_open</code>来将文件路径path和打开方式mode打包进一个特殊的数据结构中，然后通过IPC发送给文件系统，文件系统返回一个用于描述该文件的文件描述块（struct Fd，其中包含对应的文件控制块id、文件大小等）。</p><p>用户进程调用<code>fsipc_map</code>来通过指定文件控制块fileid和偏移量（以字节计），来获取指定位置的磁盘块中的数据。其打包发送给文件系统进程后，文件系统通过fileid找到对应文件，再通过offset找到对应磁盘块。磁盘块数据恰好1页大小，正好能够通过我们的IPC机制通讯传送回到用户进程。有趣的是这里面磁盘块数据涉及多次映射，一次是从磁盘中映射到文件系统进程的指定位置，一次是在IPC过程中从文件系统映射回用户进程。</p><h4 id="文件系统进程中的函数"><a href="#文件系统进程中的函数" class="headerlink" title="文件系统进程中的函数"></a>文件系统进程中的函数</h4><h5 id="fs-c"><a href="#fs-c" class="headerlink" title="fs.c"></a>fs.c</h5><p>fs.c文件定义了有关磁盘块和文件的一系列操作，主要包含两个大方面：</p><h6 id="磁盘块管理："><a href="#磁盘块管理：" class="headerlink" title="磁盘块管理："></a>磁盘块管理：</h6><p><img src="img/blog/2028226-20210523220348907-176254116.png" alt="磁盘块管理相关函数关系（部分调用省略）"></p><p>上图中表明了磁盘块管理相关函数的调用关系：</p><ul><li>绿色框内为基础检查/映射函数，不参与实际管理，仅被其他函数调用，故忽略调用关系</li><li>红色为系统调用</li><li>亮紫色为驱动程序</li></ul><ol><li><p>磁盘块位图的管理：</p><ul><li><code>alloc_block_sum</code>:遍历bitmap，找到的第一个空闲的磁盘块，然后<strong>将其写入磁盘</strong>（DEBUG:没看懂login为什么这么写，我得写个函数调用图），然后返回磁盘块号</li><li><code>alloc_block</code>:调用<code>alloc_block_sum</code>并为获得的新的磁盘块分配一个物理页面</li><li><code>free_block</code>：在位图中标记一个磁盘块为空</li><li><code>block_is_free</code>：检查位图来判断是否是空闲的</li></ul></li><li><p>磁盘块在文件系统进程空间的映射管理</p><ul><li><p><code>diskaddr</code>：实现从磁盘块号到对应虚拟地址的映射</p></li><li><p><code>map_block</code>：调用<code>syscall_mem_alloc</code>为该磁盘块分配对应的物理页面并添加进入页表</p></li><li><code>unmap_block</code>：检查是否需要将该磁盘块内容写入磁盘（取决于是否dirty），再调用<code>syscall_mem_unmap</code>释放物理页面</li><li><code>va/block_is_mapped/dirty</code>：通过查询页表来检查其是否已经被分配了物理页面/因更改而变dirty，<strong>通过检查权限位实现</strong></li></ul></li><li><p>磁盘块对应虚拟地址空间到磁盘的通过驱动程序支持的读写管理：</p><ul><li><code>read_block</code>:从磁盘中读出指定磁盘块对应的数据并存放在对应的虚拟空间里</li><li><code>write_block</code>:从虚拟空间中读出需要写入磁盘的数据并写入</li></ul></li></ol><h6 id="文件控制块管理："><a href="#文件控制块管理：" class="headerlink" title="文件控制块管理："></a>文件控制块管理：</h6><p>文件控制块管理囊括大量的文件操作函数，在这里不一一细讲。大部分函数都由课程组实现了，同学们一定要自己看一下。</p><ul><li><p><code>file_block_walk</code>:通过一个文件控制块指针和一个整数filebno，去找到该文件中第filebno个4KB起始位置对应的磁盘块号。这个函数涉及直接指针和间接指针，注意查找逻辑。</p></li><li><p><code>file_map_block</code>:将<code>file_block_walk</code>进行包装，当alloc==1时，如果没找到对应的磁盘块号，则调用<code>alloc_block</code>新建一个。</p></li><li><p><code>file_clear_block</code>:将某个磁盘块从文件中移除</p></li><li><p><code>file_get_block</code>:读取文件特定磁盘块的信息</p></li><li><p><code>file_dirty</code>:将该文件特定磁盘块设置为dirty</p></li><li><p><code>dir_lookup</code>：根据一个指向目录文件的文件控制块指针dir，找到特定名字的文件对应的文件控制块。</p><p>……</p></li></ul><p>其中<code>dir_lookup</code>函数需要我们自己实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">dir_lookup</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> File *dir, <span class="hljs-type">char</span> *name, <span class="hljs-keyword">struct</span> File **file)</span><br>&#123;<br><span class="hljs-type">int</span> r;<br>u_int i, j, nblock;<br><span class="hljs-type">void</span> *blk;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> *<span class="hljs-title">f</span>;</span><br><br>nblock = ROUND(dir-&gt;f_size, BY2BLK) / BY2BLK; <span class="hljs-comment">// 根据目录大小计算出内部磁盘块的数量</span><br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nblock; i++) &#123;<br>r = file_get_block(dir, i, &amp;blk); <span class="hljs-comment">// 读出该目录第i个磁盘块的信息并保存在blk中</span><br><span class="hljs-keyword">if</span> (r &lt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; FILE2BLK; j++) &#123;<br>            <span class="hljs-comment">// 遍历该磁盘块中所有的文件控制块</span><br>f = ((<span class="hljs-keyword">struct</span> File *)blk) + j;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(f-&gt;f_name, name) == <span class="hljs-number">0</span>)<br>&#123;<br>                <span class="hljs-comment">//如果找到目标文件，就返回</span><br>f-&gt;f_dir = dir;<br>*file = f;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> -E_NOT_FOUND; <span class="hljs-comment">// 否则报异常</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="fsformat-c"><a href="#fsformat-c" class="headerlink" title="fsformat.c"></a>fsformat.c</h5><p>该文件中存放了文件系统格式化相关的函数，包括磁盘的初始化、文件的创建、写入，主要以定义在普通文件和文件目录上的操作为主，可以看做是较为高级的文件操作集合。同样地，源码大部分已经被课程组实现了，就不再细说。</p><p>以下讲一下<code>create_file</code>函数：</p><p>这个函数从一个目录文件出发，目的是<strong>寻找第一个能够放下新的文件控制块的位置</strong>。当它找到一个指向已经被删除了的文件的文件控制块指针时，它直接返回，以求后续操作将这个空间覆盖掉。而当没有找到时，其直接进行拓展一个Block，并返回这个新的空白空间的起始地址。这里我们需要注意到，<strong>一个未被占用的空间被解释为文件控制块指针时，其行为和一个指向已经被删除了的文件的文件控制块指针一致</strong>，因此能够被统一处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> File *<span class="hljs-title function_">create_file</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> File *dirf)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> *<span class="hljs-title">dirblk</span>;</span><br>    <span class="hljs-type">int</span> i, bno, j;<br>    <span class="hljs-type">int</span> nblk = dirf-&gt;f_size / BY2BLK; <span class="hljs-comment">// 计算出该目录文件下有多少磁盘块</span><br>  <br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nblk; i++)<br>&#123;<br>        <span class="hljs-comment">// 遍历所有磁盘块</span><br><span class="hljs-keyword">if</span> (i &lt; NDIRECT)<br>&#123;<br>bno = dirf-&gt;f_direct[i];<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>bno = ((<span class="hljs-type">int</span> *)(disk[dirf-&gt;f_indirect].data))[i];<br>&#125;<br>        <span class="hljs-comment">// 根据直接指针或间接指针获得第i个磁盘块的块号</span><br>dirblk = (<span class="hljs-keyword">struct</span> File *)(disk[bno].data);<br>        <span class="hljs-comment">// 得到第i个磁盘块起始位置起算的文件控制块数组的基址</span><br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; FILE2BLK; j++)<br>&#123;<br>            <span class="hljs-comment">// 遍历该磁盘块中所有文件控制块</span><br><span class="hljs-keyword">if</span> (dirblk[j].f_name[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;\0&#x27;</span>)<br>&#123;<br>                <span class="hljs-comment">// 如果发现有的文件控制块名称为终止符，说明这个文件已经被删除了/这个文件控制块的位置还没被占用，将该文件控制块起始地址返回</span><br><span class="hljs-keyword">return</span> &amp;dirblk[j];<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 遍历了所有的Block后都没找到一个空的能放文件控制块的地方</span><br>bno = make_link_block(dirf, nblk);<br>    <span class="hljs-comment">//直接拓展dirf的大小，并使第nblk个磁盘块链接到一个新的磁盘块（块号bno）</span><br><span class="hljs-keyword">return</span> (<span class="hljs-keyword">struct</span> File *)disk[bno].data;<br>    <span class="hljs-comment">// 返回这个新的磁盘块内的起始地址</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="用户接口"><a href="#用户接口" class="headerlink" title="用户接口"></a>用户接口</h4><p>用户进程虽然通过IPC机制与文件系统通信，但是其在基本的通信逻辑上又封装了一些更为简洁的接口，存放在user/file.c中。<strong>这一部分代码基本就是对文件系统服务的封装，在这里就不一一细说</strong>。</p><p>同时用户接口中封装了一套专门用于描述文件的数据结构和逻辑，称为<strong>文件描述符</strong>，对应数据结构为struct Fd和struct Filefd。</p><h5 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fd</span> &#123;</span><br>        u_int fd_dev_id; <span class="hljs-comment">// 指示了该文件所处的设备</span><br>        u_int fd_offset; <span class="hljs-comment">// 指示了当前用户进程对该文件进行操作的指针偏移位置（从文件开头起）</span><br>        u_int fd_omode; <span class="hljs-comment">// 指示了文件的访问权限</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Filefd</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fd</span> <span class="hljs-title">f_fd</span>;</span><br>        u_int f_fileid;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> <span class="hljs-title">f_file</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>注意struct Fd.fd_offset，其描述了用户进程当前在文件操作中的指针位置，该值会在<code>read</code>、<code>write</code>和<code>seek</code>时被修改（定义在user/fd.c中）。</p><p>可以看出，Filefd实际上是Fd和File的组合，并包含了其文件控制块id。你甚至可以直接让Fd*指向Filefd类型，因为Filefd类型的内存上的前一部分存放的正是一个Fd类型的数据。</p><h5 id="fd-c"><a href="#fd-c" class="headerlink" title="fd.c"></a>fd.c</h5><p>描述了write\read\close等用户使用的接口，其基于文件描述符去寻找所需的进行的操作。</p><h5 id="file-c"><a href="#file-c" class="headerlink" title="file.c"></a>file.c</h5><p>定义了一系列基于文件控制块的函数，通过对文件控制块的解析和调用IPC来实现功能。</p><h5 id="fsipc-c"><a href="#fsipc-c" class="headerlink" title="fsipc.c"></a>fsipc.c</h5><p>定义了一系列IPC相关的函数，主要功能在于打包所要传递的参数和发送\接收。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>系统调用与Fork的实现（个人OS课设笔记节选）</title>
    <link href="/2021/06/06/OS%20Lab4%20Fork/"/>
    <url>/2021/06/06/OS%20Lab4%20Fork/</url>
    
    <content type="html"><![CDATA[<h1 id="OS课程设计-系统调用与fork实现"><a href="#OS课程设计-系统调用与fork实现" class="headerlink" title="OS课程设计 系统调用与fork实现"></a>OS课程设计 系统调用与fork实现</h1><blockquote><p>我打算从当前lab开始进行OS学习总结的分享。<br>（前几个Lab因为缺乏形式化表述，所以总是有些bug，怕发出来误人子弟。lab4对之前的lab都做了一次检查，目前代码总体上相对较为规范）</p></blockquote><p>本单元主要实现：</p><ol><li><strong>系统调用</strong>的概念和<strong>流程</strong></li><li>进程间的<strong>通讯</strong>（IPC）</li><li>fork函数实现</li><li><strong>缺页中断的处理流程</strong></li></ol><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><h3 id="什么是系统调用"><a href="#什么是系统调用" class="headerlink" title="什么是系统调用"></a>什么是系统调用</h3><p>在硬件实现上，用户态的进程无法访问内核的地址空间，这意味着：</p><ul><li>无法存取内核内存数据</li><li>无法调用内核函数</li></ul><p>而<strong>所有对硬件的操作都是内核函数</strong>，因此用户需要使用<strong>系统调用</strong>来调用内核的函数。</p><h3 id="进入系统调用"><a href="#进入系统调用" class="headerlink" title="进入系统调用"></a>进入系统调用</h3><p>一件事情在脑海中浮现，在MIPS编程中我们是这样进行输入输出——<strong>向特定寄存器存放特殊值并调用syscall</strong>。而MOS中我们也是这样做的，系统调用的关键就在于用户态和内核态的切换，而这个切换就是在我们调用syscall指令时产生的。</p><p>而就在syscall指令调用后，CPU在硬件层面陷入内核态，其将触发<strong>异常分发</strong>机制，并最终调用到<code>handle_sys()</code>函数。该函数相当于<strong>系统调用的分发</strong>，其根据某特定寄存器的值从而找到需要调用的内核函数。</p><blockquote><p>你将见到这几种函数：</p><ul><li><p>syscall_……：用户空间内的函数，与sys_……成对存在</p></li><li><p>msyscall：设置<strong>系统调用号</strong>并让系统陷入内核态的函数</p></li><li><p>sys_……：内核函数</p><p>有趣的是，在这里我们会发现msyscall需要6个参数，这引起了我们的一个新知识点：<strong>大量的参数是如何进行传递的</strong>？<br>对于$n$个参数的传递，<strong>栈帧sp会保留$n * 4$个字节的空间</strong>，而前4个参数会被放在a0到a3这四个寄存器中，但是栈帧中对应空间还是会被预留，其余参数存储在<strong>前四个参数的预留空间之上的区域</strong>。</p></li></ul></blockquote><p>注意到一个问题，<strong>多于四个的参数会被放到内存中，而这个空间是存在于用户态的</strong>，因此<strong>我们需要在内核中将这些参数转移到内核空间内</strong>，这步工作需要在<code>handle_sys()</code>函数的汇编代码实现了。</p><p>我们先来整理一下在MOS中进行系统调用的流程：</p><ol><li>调用一个封装好的用户空间的库函数（如writef）</li><li>调用用户空间的syscall_* 函数</li><li>调用msyscall，用于陷入内核态</li><li>陷入内核，内核取得信息，执行对应的内核空间的系统调用函数（sys_*）</li><li>执行系统调用，并返回用户态，同时将返回值“传递”回用户态</li><li>从库函数返回，回到用户程序调用处</li></ol><h4 id="msyscall"><a href="#msyscall" class="headerlink" title="msyscall"></a>msyscall</h4><p>msyscall执行的职能只是陷入内核态，并不涉及系统调用的分发。</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs c">syscall<br>jr ra<br>nop<br></code></pre></td></tr></table></figure><h4 id="handle-sys"><a href="#handle-sys" class="headerlink" title="handle_sys"></a>handle_sys</h4><p>syscall发生后，OS根据中断向量发现是调用了系统调用，从而通过中断分发到<code>handle_sys</code>函数。</p><p><code>handle_sys</code>函数通过分析传入的参数来找到具体的系统调用目标函数，并将传入的参数放到寄存器中，然后进入目标函数。</p><h3 id="具体系统调用函数"><a href="#具体系统调用函数" class="headerlink" title="具体系统调用函数"></a>具体系统调用函数</h3><p>所有的系统调用目标函数都在lib/syscall_all.c中定义，他们执行相应的功能，包括对页表的操作、进程的状态转换等等，在此按下不表。</p><h2 id="进程通信-IPC"><a href="#进程通信-IPC" class="headerlink" title="进程通信 IPC"></a>进程通信 IPC</h2><p>进程间通信机制是<strong>基于系统调用</strong>来实现的。通信的本质就是交换数据，而交换数据的最大问题在于：<strong>在进程间，用户地址空间相互独立</strong>。</p><p>因此，我们需要通过<strong>以内核的2g空间来作为传递信息的媒介</strong>，同时我们可以发现，进程控制块是存储在内核空间内的，因此我们完全可以将需要传递的数据放在目标的进程控制块内，然后目标进程在从中读取。</p><p><img src="img/blog/2028226-20210510193425197-1567369399.png" alt="通信过程"></p><blockquote><p><em>值得一提的是，由于在我们的用户程序中，会大量使用srcva 为0 的调用来表示不需要传递物理页面，因此在编写相关函数时也需要注意此种情况。</em></p></blockquote><p>这两个过程是通过系统调用中的<code>sys_ipc_recv</code>与<code>sys_ipc_can_send</code>来实现。</p><p>前者需要将当前接收者的进程控制块的相应域设置好，并使用<code>sys_yield</code>使得当前进程放弃CPU。</p><p>后者需要检查目标是否准备好接受，并<strong>修改目标进程的进程控制块</strong>，将需要的信息放到他们的进程控制块内。</p><blockquote><p>需要注意，<em>如果需要传递物理页面信息，需要调用sys_mem_map函数将当前进程srcva对应位置的页面映射到目标进程的dstva处</em>。</p></blockquote><h2 id="Fork函数"><a href="#Fork函数" class="headerlink" title="Fork函数"></a>Fork函数</h2><p>fork函数能够从一个进程生成另一个进程，使得子进程拥有和旧进程绝大部分相同的信息。同时，<strong>fork会在父子进程中拥有不同的返回值</strong>。</p><ul><li>在fork 之前的代码段只有父进程会执行。</li><li>在fork 之后的代码段父子进程都会执行。</li><li>fork 在不同的进程中返回值不一样，在父进程中返回值不为0，在子进程中返回值为0。</li><li>父进程和子进程虽然很多信息相同，但他们的env_id 是不同的。</li></ul><p><img src="img/blog/2028226-20210510193827711-1922362404.png" alt="Fork函数行为过程"></p><h3 id="写时复制机制"><a href="#写时复制机制" class="headerlink" title="写时复制机制"></a>写时复制机制</h3><p>父进程会为子进程设置虚拟空间，但是我们通过上图能够发现，<strong>实际的分配过程其实是通过duppage复制页表，并设置PTE_COW</strong>。COW就是写时复制的意思（Copy On Write）。</p><p>只有当父子进程中有修改内存的举动时，内核会根据PTE_COW捕获中断（一般指缺页中断，Page Fault），并单独为修改内存的进程分配物理页面，然后将该页面复制过去后再实行修改。</p><h3 id="区分父子进程的理论基础"><a href="#区分父子进程的理论基础" class="headerlink" title="区分父子进程的理论基础"></a>区分父子进程的理论基础</h3><p>fork()能够通过返回值来区别当前进程是否是子进程，若返回值为0则为子进程，否则为父进程。</p><p>而实现返回值差异性的函数是<code>syscall_env_alloc</code>函数，其属于用户函数，其触发系统调用后进行<code>sys_env_alloc</code>来创建和初始化一个新进程块。</p><h4 id="sys-env-alloc"><a href="#sys-env-alloc" class="headerlink" title="sys_env_alloc"></a>sys_env_alloc</h4><p>这个函数需要利用当前进程为模板来填写一个新的子进程块。其工作包括<strong>复制一份当前的运行现场</strong>、<strong>复制一下当前的PC值</strong>、<strong>修改子进程状态为阻塞</strong>、以及初始化其他进程控制块信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sys_env_alloc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">int</span> r;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">e</span>;</span><br>r = env_alloc(&amp;e, curenv-&gt;env_id);<br><span class="hljs-keyword">if</span> (r &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> r;<br>e-&gt;env_status = ENV_NOT_RUNNABLE;<br>e-&gt;env_pri = curenv-&gt;env_pri;<br>bcopy((<span class="hljs-type">void</span> *)KERNEL_SP - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Trapframe), (<span class="hljs-type">void</span> *)&amp;(e-&gt;env_tf), <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Trapframe));<br>e-&gt;env_tf.pc = e-&gt;env_tf.cp0_epc;<br>e-&gt;env_tf.regs[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">return</span> e-&gt;env_id; <span class="hljs-comment">// 注意这个返回值是返回到父进程的</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="在分道扬镳后，父子各自的工作"><a href="#在分道扬镳后，父子各自的工作" class="headerlink" title="在分道扬镳后，父子各自的工作"></a>在分道扬镳后，父子各自的工作</h3><h4 id="子进程"><a href="#子进程" class="headerlink" title="子进程"></a>子进程</h4><p>子进程当前虽然拥有了一个进程控制块，但是仍然存在着几个问题：</p><ul><li>子进程被第一次调度时，其处在fork函数中（准确来说，是syscall_env_alloc返回后），此时函数中的各个变量仍然指向父进程中对应数据结构，子进程如何替换掉这些变量？</li><li>子进程的用户空间没有初始化，如何实现COW的设想？</li></ul><p>我们将在子进程中解决第一个问题，而第二个问题交由父进程解决</p><h5 id="设置进程控制块"><a href="#设置进程控制块" class="headerlink" title="设置进程控制块"></a>设置进程控制块</h5><p>当从<code>syscall_env_alloc</code>返回后，子进程需要将当前函数内的进程控制块指针改为自己的。这一步通过调用<code>syscall_getenvid</code>这一系统调用实现。这一步后，子进程就能够从fork函数退出了（虽然当前处于阻塞状态）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">newenvid = syscall_env_alloc();<br><span class="hljs-keyword">if</span>(newenvid==<span class="hljs-number">0</span>) &#123;env = envs + ENVX(syscall_getenvid());<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br></code></pre></td></tr></table></figure><h4 id="父进程"><a href="#父进程" class="headerlink" title="父进程"></a>父进程</h4><p>父进程需要为子进程进行很多初始化工作，包括<strong>遍历进程空间并合理设置空间权限，实现空间共享</strong>、<strong>实现写时复制的缺页中断机制</strong></p><h5 id="进程映射"><a href="#进程映射" class="headerlink" title="进程映射"></a>进程映射</h5><p>通过遍历当前页目录，将页面按以下规则进行设置：</p><ul><li><strong>只读页面</strong> 按照相同权限（只读）映射给子进程即可</li><li><strong>共享页面</strong> 即具有PTE_LIBRARY 标记的页面，这类页面需要保持共享的可写的状态</li><li><strong>写时复制页面</strong> 即具有PTE_COW 标记的页面，这类页面是上一次的fork 的duppage的结果</li><li><strong>可写页面</strong> 需要给父进程和子进程的页表项都加上PTE_COW 标记</li></ul><p>这个功能由<code>duppage</code>函数实现。</p><h5 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h5><p>MIPS下存在两种缺页中断。一种是TLB缺失导致的缺页中断，其会触发trap并分发到<code>handle_tlb</code>下，然后按照正常逻辑进行查表、重填等，此处按下不表。</p><p>另一种是写时复制触发的缺页中断，其会触发trap分发到另一个处理函数<code>handle_mod</code>下。这个函数会跳转到<code>page_fault_handler</code>下，处理当前写时复制异常。</p><p>注意！MOS系统在此处应用了微内核的思想，<strong>将处理异常的方式交由用户进程自身</strong>，即在进程控制块内定义了一个域<code>env_pgfault_handler</code>用于指定异常处理的函数，使得用户能够自定义处理过程。</p><p>处理写时复制异常的流程为：</p><ol><li><code>page_fault_handler</code>将当前现场保存在异常处理栈中，设置epc的值，以使得中断退出后跳转到指定用户进程指定的异常处理函数中。</li><li>退出中断，此时根据epc地址跳转到指定函数（注意这个函数是fork.c中的<code>pgfault</code>函数，这意味着它是用户态下执行的）中，处理缺页，然后恢复现场和sp寄存器，令进程恢复执行。</li></ol><p><img src="img/blog/2028226-20210510193501253-604653255.png" alt="缺页中断的处理"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>面向对象设计与构造课程笔记节选</title>
    <link href="/2021/05/08/OO%20Elevator%20Problem/"/>
    <url>/2021/05/08/OO%20Elevator%20Problem/</url>
    
    <content type="html"><![CDATA[<h1 id="OO-电梯算法设计与多线程模拟"><a href="#OO-电梯算法设计与多线程模拟" class="headerlink" title="OO 电梯算法设计与多线程模拟"></a>OO 电梯算法设计与多线程模拟</h1><p>[TOC]</p><h2 id="锁和同步块的分析"><a href="#锁和同步块的分析" class="headerlink" title="锁和同步块的分析"></a>锁和同步块的分析</h2><p>本次单元作业中，线程间同步是主要的难点。在进行架构设计时，我重点考虑了<strong>通过精简共享对象层次，来简化锁和同步块的设置逻辑</strong>。</p><p>同步块中的处理语句，通常与访问、操作某一对象有关。在这里我们也考虑一个问题：<strong>行为互斥的定义</strong>，即我们究竟应该在什么情况下占有对象并构成互斥访问。显然，<strong>电梯问题中的请求传递</strong>可以看做一个Producer-Consumer问题，而<strong>调度器对电梯状态的查看</strong>是一个Read&amp;Write问题。</p><p>在第一次作业中，我没有采用调度器，而是直接通过InputThread向ElevatorThread写入请求。在这个过程中只存在简单的Producer-Consumer关系，故我在电梯的请求队列上加锁，实现InputThread放入请求和电梯处理并移除请求的互斥。</p><p>在第二次作业中，我使用调度器Controller来缓存InputThread发送的请求，并查看各个电梯的状态并据此分析请求的派发行为。因此这里又涉及一个Producer-Consumer问题，故我将Controller进行了加锁从而规范读写行为。</p><p>我刚开始将电梯的状态ElevatorStatus进行了加锁，而将Elevator的请求队列ElevatorBuffer和ElevatorStatus分开看待。随后，我仔细分析了电梯的行为，<strong>发现InputThread在获取ElevatorStatus后就会放入请求，而Elevator处理了请求后就会改变ElevatorStatus</strong>，这意味着ElevatorBuffer和ElevatorStatus具有逻辑上的耦合性，因此我将两者合并为电梯的数据集合——Elevator对象，并将Elevator的行为抽象为策略集合——ElevatorStrategy对象。ElevatorStrategy和Elevator组装为ElevatorRunnable对象，并<strong>针对Elevator这一个数据对象进行加锁</strong>。</p><p>在第三次作业中，我<strong>撤销了调度器的设计</strong>，因此不再对Controller进行加锁。同时引入了全局状态对象GlobalEnv，用于<strong>保存各个进程的状态</strong>，从而实现各个线程状态间的感知。Elevator间从等待队列中竞争请求，因此<strong>演变为Read&amp;Write问题</strong>，允许同步读、读写异步。故设置了读写互斥锁等对象（存在在GlobalEnv中）。</p><h2 id="交互架构设计"><a href="#交互架构设计" class="headerlink" title="交互架构设计"></a>交互架构设计</h2><h3 id="第一次作业"><a href="#第一次作业" class="headerlink" title="第一次作业"></a>第一次作业</h3><p>简单的从InputThread向ElevatorThread写入请求，构成Producer-Consumer模型。</p><h3 id="第二次作业"><a href="#第二次作业" class="headerlink" title="第二次作业"></a>第二次作业</h3><p>添加调度器Controller，接受InputThread发送的请求并缓存，分析每个电梯的状态并决定请求的分发。电梯只面向自己被分派到的请求进行策略调度。因此将整体策略分为两个部分——分派策略ControllerStrategy和调度策略ElevatorStrategy。</p><h3 id="第三次作业"><a href="#第三次作业" class="headerlink" title="第三次作业"></a>第三次作业</h3><p>第三次作业的更新主要在以下几点：</p><ul><li>将PersonRequest添加换乘策略PersonStrategy，包装为Person对象。</li><li>利用GlobalEnv对象进行全局对象的保存，并据此调度各个进程的退出。</li><li>移除ControllerThread，而仅保留Controller数据对象，作为请求的缓存区。</li><li>ElevatorThread从Controller中竞争请求，在每一层先将能够处理的请求预装载至自己的缓存区，然后再开门装入。</li></ul><p>Person类的包装是实现换乘的主要保证。通过<strong>Person对PersonRequest的封装</strong>，将换乘的策略写在Person类自身中，同电梯的调度策略分离，降低了电梯的职责负担。</p><p>每个Elevator都会同时观察Controller和其他电梯，当InputThread退出后且Controller为空且其他Elevator缓存区没有请求，将退出。Controller在InputThread退出且所有电梯均退出后将退出。</p><p>Elevator使用LOOK算法，<strong>具有自主选择乘客的策略，并能够通过预装载来实现电梯间的竞争</strong>，故Controller的分配策略从主动分配改为被动给予，因此Controller不再具有行为，不再需要单独的线程。</p><h2 id="第三作业架构设计及可拓展性论述"><a href="#第三作业架构设计及可拓展性论述" class="headerlink" title="第三作业架构设计及可拓展性论述"></a>第三作业架构设计及可拓展性论述</h2><h3 id="量化视角"><a href="#量化视角" class="headerlink" title="量化视角"></a>量化视角</h3><p>利用DesigniteJava对代码进行分析，获得了代码的量化评估结果：</p><p><img src="img/blog/2028226-20210422195559435-63556865.png" alt="行数统计数据"></p><p><img src="img/blog/2028226-20210422195504112-471816275.png" alt="代码Smell统计数据"></p><p>从结果上看，代码的整体的<strong>代码行数分布较为均匀且合理</strong>，符合编写规范。核心类的<strong>内聚合度高，复用性高</strong>，符合高内聚低耦合的设计要求。</p><h3 id="全局变量GlobalEnv"><a href="#全局变量GlobalEnv" class="headerlink" title="全局变量GlobalEnv"></a>全局变量GlobalEnv</h3><p>全局变量GlobalEnv应用了单例模式，用于解决共享变量传递的问题，同时能够反映整体程序的全局状态，用于指导各个线程的退出。</p><p><img src="img/blog/2028226-20210422195535804-304909211.png" alt="GlobalEnv对象"></p><h3 id="电梯Elevator"><a href="#电梯Elevator" class="headerlink" title="电梯Elevator"></a>电梯Elevator</h3><h4 id="线程运行逻辑"><a href="#线程运行逻辑" class="headerlink" title="线程运行逻辑"></a>线程运行逻辑</h4><p>电梯主要依靠ElevatorRunnable执行运行，其主要行为为做出决定，然后执行。</p><p>Elevator类除了Status外，还存放了当前电梯的<strong>类型、可抵达楼层等信息</strong>，其由ElevatorFactory进行初始化，由此实现了对电梯类型方面的可拓展性。</p><p>Decision包含一个对当前Elevator对象的引用，使得其execute方法能够改变Elevator的状态（修改当前楼层、读写缓存区请求等）。同时，<strong>Decision还能从全局变量GlobalEnv中获取Controller对象，从而在换乘时将请求放回等待队列</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">AnalyzeAndDecide</span> <span class="hljs-variable">strategy</span> <span class="hljs-operator">=</span> strategyMap.get(globalenv.getPattern());<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            Decision decision;<br>            <span class="hljs-keyword">synchronized</span> (elevator) &#123;<br>                decision = strategy.decide(elevator);<br>                <span class="hljs-keyword">if</span> (decision == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果策略决定要退出, 会返回null</span><br>                &#125;<br>            &#125;<br>            decision.execute(); <span class="hljs-comment">// 调用execute方法执行决定</span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="img/blog/2028226-20210422193013164-1380896757.png" alt="整体架构"></p><p><img src="img/blog/2028226-20210422193037410-74740467.png" alt="Decision类的架构"></p><h4 id="电梯调度算法"><a href="#电梯调度算法" class="headerlink" title="电梯调度算法"></a>电梯调度算法</h4><p>采用LOOK算法，利用有限状态机进行构造。预装载（preload）即定义了<strong>电梯的竞争行为</strong>，其从调度器中按一定条件竞争请求并预装载到自己的缓存区中。</p><p>我并没有针对各种模式进行优化，原因如下：</p><ol><li>经过测试，在全随机的Night和Morning情景下，LOOK算法能够比定制化算法具有基本相近的性能，甚至可以更好。</li><li>在边界条件下，LOOK算法具有较高的性能，与定制化算法差距不大，不会引发TLE。</li><li>考虑互测中可能遇到特意针对定制化策略的边界数据，使用定制化算法可能被狙击。</li></ol><p><img src="img/blog/2028226-20210422193052116-509484603.png" alt="电梯调度算法对应的有限自动机"></p><h3 id="PersonRequest的包装——Person类"><a href="#PersonRequest的包装——Person类" class="headerlink" title="PersonRequest的包装——Person类"></a>PersonRequest的包装——Person类</h3><p>Person类包含一个对PersonRequest的引用，并根据其分析了当前请求的换乘类型，并利用状态转换实现了换乘状态的转化。在调用了Person的getOut()方法后，其内部状态会改变，从而影响wantToGetIn()和wantToGetOut()的返回值。<strong>由于采用了状态的转换与换乘类型的独立设置</strong>，因此具有较强的拓展性，可以根据不同的类型设置不同的换乘策略而不影响其他类型的换乘行为。</p><p><img src="img/blog/2028226-20210422193119769-870604675.png" alt="Person类"></p><h3 id="线程间交互"><a href="#线程间交互" class="headerlink" title="线程间交互"></a>线程间交互</h3><p>线程间<strong>对于共享对象的互斥访问是经过特地论证的</strong>，因此避免了死锁。（事实上我实现了锁的无嵌套，将在接下来谈一下实现的Trick）。</p><p>请注意，Controller和GlobalEnv只是一个共享数据对象而并不是一个线程。</p><p>具体交互请看下图：</p><p><img src="img/blog/2028226-20210422202557927-263827552.png" alt="线程交互流程"></p><h2 id="实现Deadlock-Free的小Trick"><a href="#实现Deadlock-Free的小Trick" class="headerlink" title="实现Deadlock Free的小Trick"></a>实现Deadlock Free的小Trick</h2><p>在设计架构时我就考虑了过多的复杂的锁会造成锁的嵌套关系复杂，最终导致死锁发生时分析困难。因此，我尽量将访问上具有联系的对象打包成一个对象或共用一个锁，避免锁的嵌套。这也源自我将<strong>数据和行为</strong>分离的设想，这样使得数据之间更为集中，更利于打包成一个对象。</p><p>同时，注意<strong>及时释放锁</strong>。这里的及时释放锁既包括在不再访问对象时释放锁，也包括<strong>合理安排行为顺序，从而尽可能早地结束对对象的访问</strong>。这一点上我使用的trick是，在访问某个对象A时，<strong>如果在获得A的锁后需要访问另一个对象B（并获得B的锁）后还需要访问对象A的数据时，先拷贝对象A然后释放A的锁，再访问对象B</strong>。</p><p>最终我在程序中实现了没有锁的嵌套情况，这也使得我不用考虑死锁会带来影响。</p><h2 id="Bug测试策略"><a href="#Bug测试策略" class="headerlink" title="Bug测试策略"></a>Bug测试策略</h2><p>本单元主要测试方向在于：</p><ol><li>死锁：如何寻找对象的死锁情况？如何命中？</li><li>低效策略：如何利用边界数据卡出TLE？</li></ol><p>对于第一点，我采用<strong>直接分析代码</strong>的方式。当然，分析也需要策略。编写程序通过对synchronize关键字的嵌套查找，来自动寻找各个对象的嵌套关系。<strong>一旦发现在两个不同线程中两个对象的锁可能构成死锁</strong>，则尽可能设计数据诱导死锁的发生。诱导过程主要通过<strong>高数据量的针对性数据</strong>来实现。</p><p>对于第二点，采用特殊数据，以边界条件去测试调度算法。特殊数据的构造纯粹出于人为分析题目要求并构造，此处不再赘述。</p><h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>线程安全方面，我认为<strong>前期分析和架构设计非常重要</strong>。尽可能早地精简共享对象，使得共享关系更加简洁，避免锁的嵌套或设计合适策略来处理死锁（比如利用信号量）。只要在架构上论证了线程间的安全性，那么就可以大胆去进行具体代码的编写，无需在编写过程中再去考虑线程安全问题，这样能够提高效率也能降低后期Debug的难度。</p><h3 id="层次化设计"><a href="#层次化设计" class="headerlink" title="层次化设计"></a>层次化设计</h3><p>我理解的层次化设计，是<strong>将复杂的业务逻辑通过分析，拆分成多个层次的简单逻辑</strong>。在本次实验中<strong>将复杂的策略分担给多个对象，每个对象实现较为简单的某个特定方向上的策略</strong>，极大地降低了de策略bug时的难度，也使得我更加便捷地测试不同策略组合对于性能的影响。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
